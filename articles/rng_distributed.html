<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Distributed parallel random numbers • dust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Distributed parallel random numbers">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">dust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.15.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/dust.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/design.html">Principles and design of dust</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Random numbers</li>
    <li>
      <a href="../articles/rng.html">Random number generation</a>
    </li>
    <li>
      <a href="../articles/rng_algorithms.html">Algorithms used to compute random numbers</a>
    </li>
    <li>
      <a href="../articles/rng_package.html">Using RNGs from packages</a>
    </li>
    <li>
      <a href="../articles/rng_distributed.html">Distributed parallel random numbers</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Dive deeper</li>
    <li>
      <a href="../articles/data.html">Comparing models and data</a>
    </li>
    <li>
      <a href="../articles/gpu.html">Running models on GPUs with CUDA</a>
    </li>
    <li>
      <a href="../articles/multi.html">Multiple parameter sets</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mrc-ide/dust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Distributed parallel random numbers</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/dust/blob/master/vignettes/rng_distributed.Rmd" class="external-link"><code>vignettes/rng_distributed.Rmd</code></a></small>
      <div class="hidden name"><code>rng_distributed.Rmd</code></div>

    </div>

    
    
<!-- DO NOT EDIT THIS FILE - see vignettes_src and make changes there -->
<p>This vignette assumes some familiarity with the dust approach to
random numbers, though we provide pointers below to the relevant
documentation for further discussion.</p>
<p>The random number generator in <code>dust</code> is well suited to
parallel calculations. On a single node we can set up a generator with
many streams and then parallelise the calculation using OpenMP. The
number of streams is either one per core or, typically better, one per
logical unit of calculation (which may be the maximum number of threads,
for example one stream per loop iteration). This is the approach taken
by dust objects (<code><a href="../articles/dust.html">vignette("dust")</a></code>) and described for
standalone use of the generators
(<code><a href="../articles/rng_package.html">vignette("rng_package")</a></code>).</p>
<p>When parallelising, you may also have separate ‘nodes’, which could
be separate processors, physical machines, or just processes on the same
machine. The difference between threads is that nodes will not share any
memory with each other during processing.</p>
<p>Some additional care is required to use multiple nodes for the
calculation so their streams do not overlap (“distributed parallel
computation”), and this vignette explains the problems and solutions. It
applies to both use with <code>dust</code> objects and for standalone
use of the random number generators.</p>
<div class="section level2">
<h2 id="a-note-on-seeding">A note on seeding<a class="anchor" aria-label="anchor" href="#a-note-on-seeding"></a>
</h2>
<p>To seed multiple streams we begin by seeding the first generator.
Practically how this happens can be ignored for now.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="va"><a href="../reference/dust_rng.html">dust_rng</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">r</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] c1 5c 02 89 ec 2d 0a 91 1e 61 39 74 08 ab 41 5e c3 86 8d 6d f4 02 8a b1 56</span></span>
<span><span class="co">#&gt; [26] 49 ee d9 dd 95 81 e2</span></span></code></pre></div>
<p>To seed the next stream we “jump ahead” in the stream. The generators
provide pre-computed coefficients that jump the state of the generator
to a state equal to drawing a very large number of random numbers (or
equivalently steps of the Markov chains). For the default generator
(<code>xoshiro256+</code>) this is 2^128 draws, equal to the square root
of the period of the generator (2<sup>256</sup>1).</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">r</span><span class="op">$</span><span class="fu">jump</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">r</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] 15 6e 10 9b 13 4b 6b 88 3a 50 b0 f1 ef 99 11 5c 6f 68 1c 0f e8 97 17 40 da</span></span>
<span><span class="co">#&gt; [26] c7 c6 2e 27 b7 b7 5d</span></span></code></pre></div>
<p>Constructing a generator with more than one stream does this
automatically:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">r2</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="va"><a href="../reference/dust_rng.html">dust_rng</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">r2</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span>, <span class="fl">32</span><span class="op">)</span></span>
<span><span class="co">#&gt;       [,1] [,2] [,3] [,4]</span></span>
<span><span class="co">#&gt;  [1,]   c1   15   56   f9</span></span>
<span><span class="co">#&gt;  [2,]   5c   6e   fc   32</span></span>
<span><span class="co">#&gt;  [3,]   02   10   6d   84</span></span>
<span><span class="co">#&gt;  [4,]   89   9b   df   e6</span></span>
<span><span class="co">#&gt;  [5,]   ec   13   7b   30</span></span>
<span><span class="co">#&gt;  [6,]   2d   4b   10   34</span></span>
<span><span class="co">#&gt;  [7,]   0a   6b   6e   d2</span></span>
<span><span class="co">#&gt;  [8,]   91   88   ed   38</span></span>
<span><span class="co">#&gt;  [9,]   1e   3a   cf   f3</span></span>
<span><span class="co">#&gt; [10,]   61   50   0f   f2</span></span>
<span><span class="co">#&gt; [11,]   39   b0   57   89</span></span>
<span><span class="co">#&gt; [12,]   74   f1   0e   21</span></span>
<span><span class="co">#&gt; [13,]   08   ef   3d   72</span></span>
<span><span class="co">#&gt; [14,]   ab   99   3b   fd</span></span>
<span><span class="co">#&gt; [15,]   41   11   a2   53</span></span>
<span><span class="co">#&gt; [16,]   5e   5c   45   2b</span></span>
<span><span class="co">#&gt; [17,]   c3   6f   87   b5</span></span>
<span><span class="co">#&gt; [18,]   86   68   5d   92</span></span>
<span><span class="co">#&gt; [19,]   8d   1c   4b   2c</span></span>
<span><span class="co">#&gt; [20,]   6d   0f   86   8f</span></span>
<span><span class="co">#&gt; [21,]   f4   e8   44   25</span></span>
<span><span class="co">#&gt; [22,]   02   97   9a   9f</span></span>
<span><span class="co">#&gt; [23,]   8a   17   7d   d8</span></span>
<span><span class="co">#&gt; [24,]   b1   40   18   ae</span></span>
<span><span class="co">#&gt; [25,]   56   da   f8   c6</span></span>
<span><span class="co">#&gt; [26,]   49   c7   d0   89</span></span>
<span><span class="co">#&gt; [27,]   ee   c6   ce   79</span></span>
<span><span class="co">#&gt; [28,]   d9   2e   93   ef</span></span>
<span><span class="co">#&gt; [29,]   dd   27   a8   b0</span></span>
<span><span class="co">#&gt; [30,]   95   b7   63   42</span></span>
<span><span class="co">#&gt; [31,]   81   b7   dd   ec</span></span>
<span><span class="co">#&gt; [32,]   e2   5d   41   9f</span></span></code></pre></div>
<p>Note here how the first 32 bytes (the first column) are the same as
the initial state of the generator <code>r</code>, the second set are
equal to the state after jumping once. The third is 2 * 2^128 steps
ahead and the fourth is 3 * 2^128 steps ahead.</p>
<p>We also have coefficients for a “long jump”, which is equivalent to
2^192 steps of the generator (generator period<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>). The point of the
original jump is that individual draws of random numbers will never
overlap; the point of the long jumps is that each long jump is so far
that we’ll never reach the next one by normal jumping (there are 2^64 ~=
10^19 jumps within a single long jump).</p>
</div>
<div class="section level2">
<h2 id="distributed-seeding">Distributed seeding<a class="anchor" aria-label="anchor" href="#distributed-seeding"></a>
</h2>
<p>The basic idea using the above primitives is that we could take a set
of “long jumps” to create a set of initial seeds, pass those to each
node that will do calculation, then on each node take a set of jumps to
create a locally parallel random number generator.</p>
<p>The function <code><a href="../reference/dust_rng_distributed.html">dust::dust_rng_distributed_state</a></code> creates a
list of random number states that are suitable for use on a series of
nodes:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_state</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">1</span>, n_nodes <span class="op">=</span> <span class="fl">2L</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt;  [1] c1 5c 02 89 ec 2d 0a 91 1e 61 39 74 08 ab 41 5e c3 86 8d 6d f4 02 8a b1 56</span></span>
<span><span class="co">#&gt; [26] 49 ee d9 dd 95 81 e2</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt;  [1] 77 69 c2 44 65 7b dc 93 49 c7 93 ef dd 06 fc 47 cf af f3 d0 80 97 01 68 45</span></span>
<span><span class="co">#&gt; [26] a2 90 f4 38 dd 4d 0a</span></span></code></pre></div>
<p>Each element of this list can be passed through to to
<code>dust::dust_rng_pointer$new</code> or to create
<code><a href="../reference/dust_generator.html">dust::dust_generator</a></code> objects. It will depend on your
application how you do this of course.</p>
<p>We also include the convenience function
<code><a href="../reference/dust_rng_distributed.html">dust::dust_rng_distributed_pointer</a></code> which returns a list of
pointer objects</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_pointer</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">1</span>, n_nodes <span class="op">=</span> <span class="fl">2L</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: c1 5c 02 89 ec 2d 0a 91 1e 61 39 74 08 ab 41 5e c3 86 8d ...</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: 77 69 c2 44 65 7b dc 93 49 c7 93 ef dd 06 fc 47 cf af f3 ...</span></span></code></pre></div>
<p>We will illustrate the idea first with the pi estimation algorithm
from <code><a href="../articles/rng_package.html">vignette("rng_package")</a></code> and to start we will ignore
the within-host parallelism (imagine we’re trying to distribute the
calculation over a set of single core jobs). Because we need our code
available on multiple nodes we can’t use <code>cpp11::source_cpp</code>
and will have to create a package, which will be called
<code>piparallel</code> as before.</p>
<p>As a reminder, to use our pi estimation code on a single node we
first create a <code>dust_rng_pointer</code> object</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rng</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">:::</span><span class="va"><a href="../reference/dust_rng_pointer.html">dust_rng_pointer</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>We can call the function like so:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">piparallel</span><span class="fu">::</span><span class="fu">pi_dust_parallel</span><span class="op">(</span><span class="fl">1e6</span>, <span class="va">rng</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 3.142492</span></span></code></pre></div>
<p>To do this in parallel, we use the above functions to create a list
of pointers:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ptrs</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_pointer</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                                           n_nodes <span class="op">=</span> <span class="fl">4L</span><span class="op">)</span></span></code></pre></div>
<p>Next, we need a parallel cluster; we’ll use the <code>parallel</code>
package for this and create a cluster of two nodes (this could be
increased of course). This might be done via a cluster scheduler or the
more sophisticated tools in the <code>future</code> package.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/makeCluster.html" class="external-link">makeCluster</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"PSOCK"</span><span class="op">)</span></span></code></pre></div>
<p>We’ve installed our package in <code>lib</code> so can make sure
that’s available on each node:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterCall</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">loadNamespace</span>, <span class="st">"piparallel"</span>, <span class="va">lib</span><span class="op">)</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; &lt;environment: namespace:piparallel&gt;</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; &lt;environment: namespace:piparallel&gt;</span></span></code></pre></div>
<p>Then we can call our pi estimation function. We take as arguments the
number of iterations, a pointer to random state and the number of
threads to use.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterApply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">ptrs</span>, <span class="kw">function</span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span>
<span>                              <span class="fu">piparallel</span><span class="fu">::</span><span class="fu">pi_dust_parallel</span><span class="op">(</span><span class="fl">1e6</span>, <span class="va">r</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 3.144028</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 3.141628</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 3.141232</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 3.141676</span></span></code></pre></div>
<p>We now have four estimates of pi which are independent and can be
safely averaged:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 3.142141</span></span></code></pre></div>
<p>These are the same numbers we would have found had we run things in
series locally:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ptrs_local</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_pointer</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                                                 n_nodes <span class="op">=</span> <span class="fl">4L</span><span class="op">)</span></span>
<span><span class="va">ans_local</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">ptrs_local</span>, <span class="kw">function</span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span>
<span>                    <span class="fu">piparallel</span><span class="fu">::</span><span class="fu">pi_dust_parallel</span><span class="op">(</span><span class="fl">1e6</span>, <span class="va">r</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans_local</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 3.144028</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 3.141628</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 3.141232</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 3.141676</span></span></code></pre></div>
<p>If we’d run the <code>clusterApply</code> over a different number of
nodes, the calculation would also be unchanged.</p>
<p>The same approach works where we want each node to run in parallel.
So we might want to distribute calculations over 4 nodes which each have
8 cores say. Then we’d configure our pointers to have more streams (here
using 32 streams as that might represent our upper bound of per-node
compute capacity)</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ptrs</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_pointer</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">32</span>,</span>
<span>                                           n_nodes <span class="op">=</span> <span class="fl">4L</span><span class="op">)</span></span></code></pre></div>
<p>The state vector for each pointer is now considerably longer:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">ptrs</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1024</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">ptrs</span>, <span class="kw">function</span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span>
<span>              <span class="fu">piparallel</span><span class="fu">::</span><span class="fu">pi_dust_parallel</span><span class="op">(</span><span class="fl">1e6</span>, <span class="va">r</span>, <span class="fl">8</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [1] 3.142302</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [1] 3.141256</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [1] 3.141828</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [1] 3.140525</span></span></code></pre></div>
<p>As before, this gives us four answers (two per node) but each node
ran 2 * 32 * 1e6 random draws, spread over 8 threads in two serial
jobs.</p>
<p>With this set-up we can change the number of nodes and number of
threads without affecting the calculation, but spread the work out over
the compute that we have available to us.</p>
</div>
<div class="section level2">
<h2 id="continuing-the-streams">Continuing the streams<a class="anchor" aria-label="anchor" href="#continuing-the-streams"></a>
</h2>
<p>The above set-up assumes that we want to establish our streams, do
some work with them, then throw them away. That is, we never want to run
calculations on the same nodes again. To sensibly we have several
choices:</p>
<p><strong>Take another set of long jumps to jump over all partial
series used and continue from there.</strong> Possibly the simplest
solution; if we have set up initial states for <code>n</code> nodes and
we have our initial seed we can simply take <code>n</code> long jumps to
move away from our initial sequence, then configure seeds using the next
<code>n</code> states. This can be repeated without practical limit. It
has the advantage that no reverse communication needs to happen about
the random number seed - that is, the worker nodes never need to tell
our main node where they got to in the sequence.</p>
<p><strong>Report back the final state reached by each node.</strong> A
more involved solution, but possibly more satisfying, involves each node
sending back its final state at the end of sampling (along with whatever
calculations were being performed). We then pass this state back to the
nodes when continuing so that all calculations are taken from an
unbroken set of streams.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pi_estimate_continue</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span>, <span class="va">ptr</span>, <span class="va">n_threads</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">value</span> <span class="op">&lt;-</span> <span class="fu">piparallel</span><span class="fu">::</span><span class="fu">pi_dust_parallel</span><span class="op">(</span><span class="va">n</span>, <span class="va">ptr</span>, <span class="va">n_threads</span><span class="op">)</span></span>
<span>  <span class="va">ptr</span><span class="op">$</span><span class="fu">sync</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>value <span class="op">=</span> <span class="va">value</span>,</span>
<span>       ptr <span class="op">=</span> <span class="va">ptr</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterExport</a></span><span class="op">(</span><span class="va">cl</span>, <span class="st">"pi_estimate_continue"</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ptrs</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_pointer</a></span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1</span>, n_streams <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                                           n_nodes <span class="op">=</span> <span class="fl">4L</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterApply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">ptrs</span>, <span class="kw">function</span><span class="op">(</span><span class="va">r</span><span class="op">)</span></span>
<span>                              <span class="fu">pi_estimate_continue</span><span class="op">(</span><span class="fl">1e6</span>, <span class="va">r</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; [[1]]$value</span></span>
<span><span class="co">#&gt; [1] 3.144028</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[1]]$ptr</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: 3c 9a e0 2e ac 65 52 0d b4 be 20 c8 cd c5 9e 27 82 14 7e ...</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt; [[2]]$value</span></span>
<span><span class="co">#&gt; [1] 3.141628</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[2]]$ptr</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: 2e 3d 0e 9c fb a7 d3 08 f3 32 89 25 c1 38 b8 aa 95 0b 65 ...</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt; [[3]]$value</span></span>
<span><span class="co">#&gt; [1] 3.141232</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[3]]$ptr</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: 7f b4 7d 26 a0 13 11 24 20 95 93 02 4b 3d 16 9d ba cf a2 ...</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[4]]</span></span>
<span><span class="co">#&gt; [[4]]$value</span></span>
<span><span class="co">#&gt; [1] 3.141676</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; [[4]]$ptr</span></span>
<span><span class="co">#&gt; &lt;dust_rng_pointer&gt;</span></span>
<span><span class="co">#&gt;   Public:</span></span>
<span><span class="co">#&gt;     algorithm: xoshiro256plus</span></span>
<span><span class="co">#&gt;     initialize: function (seed = NULL, n_streams = 1L, long_jump = 0L, algorithm = "xoshiro256plus")</span></span>
<span><span class="co">#&gt;     is_current: function ()</span></span>
<span><span class="co">#&gt;     n_streams: 1</span></span>
<span><span class="co">#&gt;     state: function ()</span></span>
<span><span class="co">#&gt;     sync: function ()</span></span>
<span><span class="co">#&gt;   Private:</span></span>
<span><span class="co">#&gt;     is_current_: TRUE</span></span>
<span><span class="co">#&gt;     ptr_: externalptr</span></span>
<span><span class="co">#&gt;     state_: a0 46 22 8e b9 e5 e8 fe 37 99 06 e4 18 2d 13 f3 25 33 fb ...</span></span></code></pre></div>
<p>We can again assemble our answer, which agrees with above</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">vapply</a></span><span class="op">(</span><span class="va">ans</span>, <span class="st">"[["</span>, <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">numeric</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="st">"value"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 3.142141</span></span></code></pre></div>
<p>The state of these pointers now also agrees with above;</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ptrs_local</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] 3c 9a e0 2e ac 65 52 0d b4 be 20 c8 cd c5 9e 27 82 14 7e 79 c2 8f fb 47 4c</span></span>
<span><span class="co">#&gt; [26] 00 da 0f 97 50 f7 f6</span></span>
<span><span class="va">ans</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">ptr</span><span class="op">$</span><span class="fu">state</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] 3c 9a e0 2e ac 65 52 0d b4 be 20 c8 cd c5 9e 27 82 14 7e 79 c2 8f fb 47 4c</span></span>
<span><span class="co">#&gt; [26] 00 da 0f 97 50 f7 f6</span></span></code></pre></div>
<p>This approach could be useful where the calculation is to be
continued (for example iterating until some convergence criteria is
met). The additional work of synchronising and returning the pointer
adds complexity though.</p>
</div>
<div class="section level2">
<h2 id="considerations">Considerations<a class="anchor" aria-label="anchor" href="#considerations"></a>
</h2>
<p>Ideally the calculations will not depend on number of nodes used, so
you should take the same approach as described in
<code><a href="../articles/rng_package.html">vignette("rng_package")</a></code> and try and identify the
“parallelisable” component (which might be larger than the number of
nodes) and parallelise based on that.</p>
<p>For example, suppose we want to run a multi-chain MCMC simulation.
Parallelising across chains is an obvious between-node target. We could
then send <code>n</code> chains over <code>m</code> nodes
(<code>m &lt;= n</code>) and we’d want to arrange our seeds so that we
long-jump for each <em>chain</em> not over each node as that way no
matter how many nodes we had available we’d get the same results.</p>
</div>
<div class="section level2">
<h2 id="use-cases">Use cases<a class="anchor" aria-label="anchor" href="#use-cases"></a>
</h2>
<p>Here we show a more complete, and less contrived, use case with
dust’s “volatility” model. This example picks up from
<code><a href="../articles/data.html">vignette("data")</a></code> and the reader is directed there for a
fuller explanation.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">volatility</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_example.html">dust_example</a></span><span class="op">(</span><span class="st">"volatility"</span><span class="op">)</span></span></code></pre></div>
<p>The model was written to fit to a time series:</p>
<p>The model can run in parallel on a single node to produce a
likelihood estimate given parameters, we’ll write a small function to do
this:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">run_filter</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pars</span>, <span class="va">mod</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/any.html" class="external-link">any</a></span><span class="op">(</span><span class="va">pars</span> <span class="op">&lt;</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="op">-</span><span class="cn">Inf</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>alpha <span class="op">=</span> <span class="va">pars</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, sigma <span class="op">=</span> <span class="va">pars</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">mod</span><span class="op">$</span><span class="fu">update_state</span><span class="op">(</span>pars <span class="op">=</span> <span class="va">pars</span>, time <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="va">mod</span><span class="op">$</span><span class="fu">filter</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">log_likelihood</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We assume that our parameter vector here is a length-2 numeric vector
with values <code>alpha</code> and <code>sigma</code> and ensure that
these are positive by returning <code>-Inf</code> if invalid values are
given.</p>
<p>We can create an instance of the model, set the data, and run the
filter (for details see <code><a href="../articles/data.html">vignette("data")</a></code>)</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_particles</span> <span class="op">&lt;-</span> <span class="fl">128</span></span>
<span><span class="va">n_threads</span> <span class="op">&lt;-</span> <span class="fl">4</span></span>
<span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="va">volatility</span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, <span class="fl">0</span>, <span class="va">n_particles</span>, n_threads <span class="op">=</span> <span class="va">n_threads</span><span class="op">)</span></span>
<span><span class="va">mod</span><span class="op">$</span><span class="fu">set_data</span><span class="op">(</span><span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_data.html">dust_data</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; NULL</span></span>
<span><span class="fu">run_filter</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.91</span>, <span class="fl">1</span><span class="op">)</span>, <span class="va">mod</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -179.0706</span></span></code></pre></div>
<p>We could also write a very simple MCMC using the Metropolis-Hastings
algorithm:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mcmc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mod</span>, <span class="va">p</span>, <span class="va">n_times</span>, <span class="va">proposal_sd</span> <span class="op">=</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">ll</span> <span class="op">&lt;-</span> <span class="fu">run_filter</span><span class="op">(</span><span class="va">p</span>, <span class="va">mod</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">ret</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA_real_</span>, <span class="va">n_times</span> <span class="op">+</span> <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">ret</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">ll</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="va">n_times</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">p_new</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">p</span><span class="op">)</span>, <span class="va">p</span>, <span class="va">proposal_sd</span><span class="op">)</span></span>
<span>    <span class="va">ll_new</span> <span class="op">&lt;-</span> <span class="fu">run_filter</span><span class="op">(</span><span class="va">p_new</span>, <span class="va">mod</span><span class="op">)</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">ll_new</span> <span class="op">&gt;</span> <span class="va">ll</span> <span class="op">||</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">ll_new</span> <span class="op">-</span> <span class="va">ll</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">ll</span> <span class="op">&lt;-</span> <span class="va">ll_new</span></span>
<span>      <span class="va">p</span> <span class="op">&lt;-</span> <span class="va">p_new</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">ret</span><span class="op">[</span><span class="va">i</span> <span class="op">+</span> <span class="fl">1</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">ll</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">ret</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We can run this for a number of steps and collect up sampled
parameters and their likelihoods</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">mcmc</span><span class="op">(</span><span class="va">mod</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.91</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>(We are cutting a lot of corners with the inference here; we have not
specified any priors and are assuming that the distribution can be
integrated over the parameters, and our proposal mechanism is extremely
simple supporting only orthogonal proposals of the two parameters which
are certainly correlated. However, the basic features are shared with
any more sophisticated approach.)</p>
<p>Our aim here is now to carry this out in parallel, where we run a
chain per node. To do this we need to do the same basic steps as above.
If we want to run 8 chains we’ll need 8 seeds, even if we run on fewer
nodes:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">seed</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_rng_distributed.html">dust_rng_distributed_state</a></span><span class="op">(</span>n_nodes <span class="op">=</span> <span class="fl">8L</span>, algorithm <span class="op">=</span> <span class="va">volatility</span><span class="op">)</span></span></code></pre></div>
<p>It will also be useful to write a little wrapper function that
repeats the setup from above, then runs the MCMC:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">run_mcmc</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">seed</span>, <span class="va">data</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">volatility</span> <span class="op">&lt;-</span> <span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_example.html">dust_example</a></span><span class="op">(</span><span class="st">"volatility"</span><span class="op">)</span></span>
<span>  <span class="va">mod</span> <span class="op">&lt;-</span> <span class="va">volatility</span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>, <span class="fl">0</span>, <span class="fl">128</span>, seed <span class="op">=</span> <span class="va">seed</span>, n_threads <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="va">mod</span><span class="op">$</span><span class="fu">set_data</span><span class="op">(</span><span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_data.html">dust_data</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu">mcmc</span><span class="op">(</span><span class="va">mod</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterExport</a></span><span class="op">(</span><span class="va">cl</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mcmc"</span>, <span class="st">"run_mcmc"</span>, <span class="st">"run_filter"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/clusterApply.html" class="external-link">clusterApply</a></span><span class="op">(</span><span class="va">cl</span>, <span class="va">seed</span>, <span class="va">run_mcmc</span>, <span class="va">data</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.91</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>This produces a list of samples from each of the 8 chains, run over 2
nodes, each of which ran using 2 threads. We can scale any of this
parallelism (increasing threads until we hit the total number of
particles, increasing nodes until we hit the number of chains) but the
results will be deterministic (except for the call to <code>runif</code>
that we use here for the acceptance test within the MCMC).</p>
<p>Note that in creating the seed above we left <code>n_streams</code>
as the default (1) because the dust model constructor will take care of
expanding out per-particle seeds via a series of jumps.</p>
<p>You should be careful with these approaches to not exceed the compute
available to you, especially when using a multi-user system such as an
HPC.</p>
</div>
<div class="section level2">
<h2 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<ul>
<li>
<em>Simplest</em>: create a set of suitable rng seeds on the
controlling node and send them to the worker nodes, don’t try and
continue calculations afterwards.</li>
<li>Create a set of pointer objects which could be used on the
controlling process first, then sent to the worker nodes</li>
<li>
<em>Hardest</em>: create a set of pointer objects and send them to
the worker nodes, then at the end of the calculation synchronise the
state and return to the controlling node</li>
</ul>
<hr>
<p>[^1] It’s hard to get a sense of these numbers but <code>2^128</code>
is about <code>3 x 10^38</code> draws. If we draw a billion numbers
(10^9) a second (1ns per draw is the rate on a reasonable CPU) we can
draw 3 x 10^16 numbers a year, so at this rate it would take this would
take 10^22 years to reach the next stream. In contrast, the universe is
14 billion years old (1.4 x 10^10 years).</p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>3/4<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Rich FitzJohn, Alex Hill, John Lees.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

      </footer>
</div>






  </body>
</html>
