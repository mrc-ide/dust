<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Principles and design of dust • dust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Principles and design of dust">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">dust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.15.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/dust.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/design.html">Principles and design of dust</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Random numbers</li>
    <li>
      <a href="../articles/rng.html">Random number generation</a>
    </li>
    <li>
      <a href="../articles/rng_algorithms.html">Algorithms used to compute random numbers</a>
    </li>
    <li>
      <a href="../articles/rng_package.html">Using RNGs from packages</a>
    </li>
    <li>
      <a href="../articles/rng_distributed.html">Distributed parallel random numbers</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Dive deeper</li>
    <li>
      <a href="../articles/data.html">Comparing models and data</a>
    </li>
    <li>
      <a href="../articles/gpu.html">Running models on GPUs with CUDA</a>
    </li>
    <li>
      <a href="../articles/multi.html">Multiple parameter sets</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mrc-ide/dust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Principles and design of dust</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/dust/blob/master/vignettes/design.Rmd" class="external-link"><code>vignettes/design.Rmd</code></a></small>
      <div class="hidden name"><code>design.Rmd</code></div>

    </div>

    
    
<p>Fundamentally, using a computer to create a realisation from
stochastic Monte Carlo models is extremely simple. Consider a random
walk in one dimension - we might write that in base R functions by
creating a function that takes a current state <code>state</code> and a
list of parameters:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">update_walk</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">state</span>, <span class="va">pars</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">state</span>, <span class="va">pars</span><span class="op">$</span><span class="va">sd</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>and then iterating it for 20 time steps with:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>sd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">20</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">update_walk</span><span class="op">(</span><span class="va">y</span>, <span class="va">pars</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>At the end of this process, the variable <code>y</code> contains a
new value, corresponding to 20 time steps with our stochastic update
function.</p>
<p>So why does <code>dust</code> apparently require thousands of lines
of code to do this?</p>
<div class="section level2">
<h2 id="running-multiple-realisations">Running multiple realisations<a class="anchor" aria-label="anchor" href="#running-multiple-realisations"></a>
</h2>
<p>It’s very rare that one might want to run a single stochastic
simulation; normally we want to run a group together. There are several
ways that we might want to do that:</p>
<ul>
<li>For a single set of parameters and a starting state run a set of
simulations, as they will differ due to the stochasticity in the
model</li>
<li>In addition to the above, perhaps run with different starting
points, representing uncertainty in initial conditions</li>
<li>In addition to the above, run for many parameter sets at once
possibly with one particle per parameter, possibly with many per
parameter</li>
<li>In addition to the above, the parameters themselves are grouped into
blocks</li>
</ul>
<p>There book-keeping for this can get tedious and error prone if done
by hand. In <code>dust</code>, we try and restrict concern about this to
a few points, and for the simulation itself – the interaction that we
expect to take the longest in any interesting model – we just run a big
loop over time and all particles no matter what type of structure they
might represent from the above.</p>
<p>See <code><a href="../articles/multi.html">vignette("multi")</a></code> for details of interacting with
different ways that you might want to structure your simulations.</p>
</div>
<div class="section level2">
<h2 id="parallelisation">Parallelisation<a class="anchor" aria-label="anchor" href="#parallelisation"></a>
</h2>
<p>Once we’re running multiple simulations at once, even a simple
simulation might start taking a long time and because they are
independent we might look to parallelism to try and speed up the
simulations.</p>
<p>However, one cannot just draw multiple numbers from a single random
number generator at once. That is, given a generator like those built
into R, there is no parallel equivalent to</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<p>that would draw the 10 numbers in parallel rather than in series.
When drawing a random number there is a “<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" class="external-link">side
effect</a>” of updating the random number state. That is because the
random number stream is <em>also</em> a Markov chain!</p>
<p>As such it makes sense (to us at least) to store the state of each
stream’s random number generator separately, so if we have
<code>n</code> particles within a <code>dust</code> object we have
<code>n</code> separate streams, and we might think of the model state
as being the state that is declared by the user as a vector of floating
point numbers alongside the random number state. During each model step,
the model state is updated and so is the random number state.</p>
<p>This might seem wasteful, and if we used the popular <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" class="external-link">Mersenne
Twister</a> it would be to some degree as each particle would require
2560 bytes of additional state. In contrast the newer <a href="https://prng.di.unimi.it/" class="external-link">xoshiro</a> generators that we use
require only 32 or 16 bytes of state; the same as 4 double- or
single-precision floating point numbers respectively. So for any
nontrivial simulation it’s not a very large overhead.</p>
<p>Setting the seed for these runs is not trivial, particularly as the
number of simultaneous particles increase. If you’ve used random numbers
with the <a href="https://cran.r-project.org/package=future" class="external-link">future</a>
package you may have seen it raise a warning if you do not configure it
to use a “L’Ecuyer-CMRG” which adapts R’s native random number seeds to
be safe in parallel.</p>
<p>The reason for this is that if different streams start from seeds
that are set via poor heuristics (e.g., system time and thread id) they
might be exactly the same. If they were set randomly, then they might
collide (see <a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/" class="external-link">John
Cook’s description of the birthday paradox here</a>) and if they are
picked sequentially there’s no guarantee that these streams might not be
correlated.</p>
<p>Ideally we want a similar set of properties to R’s
<code>set.seed</code> method; the user provides an arbitrary integer and
we seed <em>all</em> the random number streams using this in a way that
is reproducible and also statistically robust. We also want the streams
to be reproducible even when the number of particles changes, for
particle indices that are shared. The random number generators we use
(the xoshiro family, a.k.a. Blackmann-Vigna generators) support these
properties and are described more fully in
<code><a href="../articles/rng.html">vignette("rng")</a></code>.</p>
<p>To initialise our system with a potentially very large number of
particles we take two steps:</p>
<ul>
<li>First, we seed the first stream using the <code>splitmix64</code>
RNG, following the xoshiro docs. This expands a single 64-bit integer
into the 256-bits of RNG state, while ensuring that the resulting full
random number seed does not contain all zeros.</li>
<li>Then, for each subsequent chain we take a “jump” in the sequence.
This is a special move implemented by the RNG that is equivalent to a
very large number of draws from the generator (e.g., about 2^128 for the
default generator used for double-precision models) ensuring that each
particles state occupies a non-overlapping section of the underling
random number stream (see <code><a href="../articles/rng.html">vignette("rng")</a></code> for
details).</li>
</ul>
<p>With this setup we are free to parallelise the system as each
realisation is completely independent of each other; the problem has
become “<a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" class="external-link">embarrassingly
parallel</a>”. In practice we do this using <a href="https://www.openmp.org/" class="external-link">OpenMP</a> where available as this is
well supported from R and gracefully falls back on serial operation
where not available. See <code><a href="../reference/dust_openmp_support.html">dust::dust_openmp_support</a></code> for
information on your system’s OpenMP configuration as seen by R:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">dust</span><span class="fu">::</span><span class="fu"><a href="../reference/dust_openmp_support.html">dust_openmp_support</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; $num_procs</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $max_threads</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $thread_limit</span></span>
<span><span class="co">#&gt; [1] 2147483647</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $openmp_version</span></span>
<span><span class="co">#&gt; [1] 201511</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $has_openmp</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $mc.cores</span></span>
<span><span class="co">#&gt; [1] NA</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $OMP_THREAD_LIMIT</span></span>
<span><span class="co">#&gt; [1] NA</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $OMP_NUM_THREADS</span></span>
<span><span class="co">#&gt; [1] NA</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $MC_CORES</span></span>
<span><span class="co">#&gt; [1] NA</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $limit_r</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $limit_openmp</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $limit</span></span>
<span><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>As the number of threads changes, the results will not change; the
same calculations will be carried out and the same random numbers drawn.
The number of threads used can even be changed for a model while it is
running if the computational resources available change during a model
run, using the <code>$set_n_threads()</code> method.</p>
<p>Sometimes we might parallelise beyond one computer (e.g., when using
a cluster), in which case we cannot use OpenMP. We call this case
“distributed parallelism” and cope by having each process take a “long
jump” (an even larger jump in the random number space), then within the
process proceed as above. This is the approach taken in our <a href="https://mrc-ide.github.io/mcstate/" class="external-link"><code>mcstate</code></a>
package for organising running MCMC chains in parallel, each of which
works with a dust model.</p>
<p>The properties of the random number generator are discussed further
in <code><a href="../articles/rng.html">vignette("rng")</a></code>.</p>
</div>
<div class="section level2">
<h2 id="efficient-running">Efficient running<a class="anchor" aria-label="anchor" href="#efficient-running"></a>
</h2>
<p>A general rule-of-thumb is to avoid unneeded memory allocations in
tight loops; with this sort of stochastic iteration everything is a
tight loop! However, we’ve reduced the problem scope to just providing
an update method, and as long as that does not issue memory allocations
then the whole thing runs in fixed space without having to worry.</p>
</div>
<div class="section level2">
<h2 id="efficient-state-handling">Efficient state handling<a class="anchor" aria-label="anchor" href="#efficient-state-handling"></a>
</h2>
<p>For nontrivial systems, we often want to record a subset of states -
potentially a very small fraction of the total states computed. For
example, in our <a href="https://mrc-ide.github.io/sircovid/" class="external-link">sircovid</a> model we track
several thousand states (representing populations in various stages of
disease transmission, in different ages, with different vaccination
status etc), but most of the time we only need to report on a few tens
of these in order to fit to data or to examine key outputs.</p>
<p>Reducing the number of state variables returned at different points
in the process has several advantages:</p>
<ul>
<li>Saving space: if you run a model with 2000 states, 1000 replicates
and record their trajectories over 100 timesteps, that represents 100
million floating point numbers, or 1.6 GB of memory or disk if using
double-precision numbers. These are not unrealistic numbers, but would
make even a simple sensitivity analysis all-but impossible to work
with.</li>
<li>Saving time: copying data around is surprisingly slow.</li>
</ul>
<p>To enable this, you can restrict the state returned by most methods;
some by default and others when you call them.</p>
<ul>
<li>The <code>$run()</code> and <code>$simulate()</code> methods move
the system forwards in time and returns the state at that point; it uses
an index set into the object with <code>$set_index()</code>. The
intention here is that these would be repeatedly called and so we
validate the index once and use it over and over.</li>
<li>The <code>$state()</code> method returns the model state and accepts
an argument <code>index</code> as the state to return</li>
</ul>
<p>In both cases, if <code>index</code> was named then the returned
state carries these names as its rownames.</p>
<p>The ordering of the state is important; we always have dimensions
that will contain:</p>
<ol style="list-style-type: decimal">
<li>the model states within a single particle</li>
<li>the particles within a time-step (may be several dimensions; see
<code><a href="../articles/multi.html">vignette("multi")</a></code>)</li>
<li>the time dimension if using <code>simulate</code>
</li>
</ol>
<p>This is to minimise repeatedly moving around data during writing, and
to help with concatenation. Multiple particles data is stored
consecutively and read and written in order. Each time step is written
at once. And you can append states from different times easily. The
base-R <code><a href="https://rdrr.io/r/base/aperm.html" class="external-link">aperm()</a></code> function will be useful for reshaping this
output to a different dimension order if you require one, but it can be
very slow.</p>
<p>In order to pull all of this off, we allocate all our memory up
front, in C++ and pass back to R a “pointer” to this memory, which will
live for as long as your model object. This means that even if your
model requires GBs of memory to run, it is never copied back and forth
into R (where it would be subject to R’s <a href="https://en.wikipedia.org/wiki/Copy-on-write" class="external-link">copy-on-write
semantics</a> but instead accessed only when needed, and written to in
place following C++ reference semantics.</p>
</div>
<div class="section level2">
<h2 id="useful-verbs">Useful verbs<a class="anchor" aria-label="anchor" href="#useful-verbs"></a>
</h2>
<p>We try and provide verbs that are useful, given that the model
presents a largely opaque pointer to model state. These are driven by
our needs for running a particle filter.</p>
<p>Normally we have in the object several things:</p>
<ul>
<li>the random number state: this is effectively a matrix of integers
(either <code>uint32_t</code> or <code>uint64_t</code>)</li>
<li>the model state: this is effectively a matrix of floating point
numbers, (typically either <code>float</code> or
<code>double</code>)</li>
<li>the model parameters: this is specific to the model in question (and
these are likely shared across multiple particles). This is presented to
all particles within a group as an immutable pointer, which allows safe
simultaneous access by multiple threads</li>
<li>the model <em>internal state</em>: this is also specific to the
model and dust has no control over this. Because each particle has its
own state they can safely write to it when running parallel (compare
with parameters). Typically this space is <em>allocated</em> at model
construction. For models that come from <a href="https://mrc-ide.github.io/odin.dust/" class="external-link">odin.dust</a> this is used
as “scratch” space that we write to during an update but which does not
conceptually persist between steps. Importantly, this space is assumed
to be unimportant to specifying model state (i.e., we can shuffle or
reset thee model state while leaving the “internal” data behind).</li>
</ul>
<p>The internal state is the the hardest to understand in this set.
Suppose that we had a model that each time step we wanted to do
something like take the median value found in a set of random number
draws. We might want to write the update function like</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>  <span class="kw">struct</span> <span class="dt">internal_type</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;</span> samples<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="dt">void</span> update<span class="op">(</span><span class="dt">size_t</span> time<span class="op">,</span> <span class="at">const</span> <span class="dt">real_type</span> <span class="op">*</span> state<span class="op">,</span> <span class="dt">rng_state_type</span><span class="op">&amp;</span> rng_state<span class="op">,</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>              <span class="dt">real_type</span> <span class="op">*</span> state_next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> shared<span class="op">-&gt;</span>n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>      internal<span class="op">.</span>samples<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dust<span class="op">::</span>random<span class="op">::</span>uniform<span class="op">(</span>rng_state<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>    state_next<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> median<span class="op">(</span>samples<span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>with median defined as something like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>T median<span class="op">(</span>U<span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> m <span class="op">=</span> v<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="bu">std::</span>nth_element<span class="op">(</span>u<span class="op">.</span>begin<span class="op">(),</span> u<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> m<span class="op">,</span> u<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="cf">return</span> v<span class="op">[</span>m<span class="op">];</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>this takes advantage of some internal space of the correct size in
internal memory. This might be configured with</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>dust<span class="op">::</span><span class="dt">pars_type</span><span class="op">&lt;</span>model<span class="op">&gt;</span> dust_pars<span class="op">&lt;</span>model<span class="op">&gt;(</span>cpp11<span class="op">::</span>list pars<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="kw">using</span> <span class="dt">real_type</span> <span class="op">=</span> <span class="kw">typename</span> model<span class="op">::</span><span class="dt">real_type</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="kw">auto</span> shared <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>model<span class="op">::</span><span class="dt">shared_type</span><span class="op">&gt;();</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  shared<span class="op">-&gt;</span>n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  model<span class="op">::</span><span class="dt">internal_type</span> internal<span class="op">{</span><span class="bu">std::</span>vector<span class="op">&lt;</span>model<span class="op">::</span><span class="dt">real_type</span><span class="op">&gt;(</span>shared<span class="op">-&gt;</span>n<span class="op">)};</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  <span class="cf">return</span> dust<span class="op">::</span><span class="dt">pars_type</span><span class="op">&lt;</span>model<span class="op">&gt;(</span>shared<span class="op">,</span> internal<span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There is one additional subtlety about internal state: we assume that
the state entirely specifies a model in a Markov process, and so we
don’t guarantee that models with mutable internal state will not be
discarded between each iteration. Above, <code>samples</code> is
configured in the <code>dust_pars</code> method (so allocated there),
and is used in <code>update</code>, but it should not be read from
within the <code>update</code> method before it is written to, because
it might contain some other particle’s scratch space.</p>
<p>The reason why this is important is because if we reorder particles
what we really do is reorder the <em>state vector</em> and not this
internal state. This prevents implementing things like models with
“delays” in the current design. We may relax constraint this if it is
needed.</p>
<p>Given this, the sorts of verbs that we need include:</p>
<ul>
<li>Running the model up to a time point (<code>$run</code>) - runs the
model’s <code>update</code> method as many times as required to reach
the new time point, returning the model state at this time point. This
is useful where you might want to change the system at this time point,
then continue.</li>
<li>Running the model and collecting history (<code>$simulate</code>) -
as for <code>$run</code> but also collects partial state at a number of
times along the way. This always has one more dimension than
<code>$run</code> (being time) and the two functions coexist so that
dimensionality is easy to program against.</li>
<li>Setting model state (<code>$update_state</code>) - leaves RNG state
and parameters untouched but replaces model state for all particles.
This is useful for model initialisation and for performing arbitrary
model state and/or parameter changes.</li>
</ul>
<p>In addition, we have more specific methods oriented towards <a href="https://en.wikipedia.org/wiki/Particle_filter" class="external-link">particle
filtering</a>:</p>
<ul>
<li>Reordering the particles (<code>$reorder</code>) - shuffles particle
state among particles within a parameter set. This is useful for
implementing a resampling algorithms and updates only the state (as for
<code>$update_state</code>, leaving RNG state and internal state
untouched)</li>
<li>Resampling particles according to some weight vector
(<code>$resample</code>) which implements a bootstrap sampling algorithm
on top of <code>$reorder</code>
</li>
<li>Run a bootstrap particle filter (<code>$filter</code>) which is
implemented using the above methods, in the case where the model
provides a compare function. This is likely to be a bit low level for
direct use, and is better approached via the interface in <a href="https://mrc-ide.github.io/mcstate/" class="external-link">mcstate</a>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="a-compilation-target">A compilation target<a class="anchor" aria-label="anchor" href="#a-compilation-target"></a>
</h2>
<p>The most esoteric design of dust is to make it convenient to use as a
target for other programs. We use the package primarily as a target for
models written in <a href="https://mrc-ide.github.io/odin/" class="external-link"><code>odin</code></a> via <a href="https://mrc-ide.github.io/odin.dust/" class="external-link">odin.dust</a>. This allows
the user to write models at a very high level, describing the updates
between steps. The random walk example at the beginning of this document
might be implemented as</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sd</span> <span class="op">&lt;-</span> <span class="fu">user</span><span class="op">(</span><span class="op">)</span>              <span class="co"># user-provided standard deviation</span></span>
<span><span class="fu">initial</span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">0</span>           <span class="co"># starting point of the simulation</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">y</span>, <span class="va">sd</span><span class="op">)</span> <span class="co"># take random step each time step</span></span></code></pre></div>
<p>which will compile a dust model:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co">// [[dust::class(odin)]]</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">// [[dust::param(sd, has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="kw">class</span> odin <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="kw">using</span> <span class="dt">real_type</span> <span class="op">=</span> <span class="kw">typename</span> model<span class="op">::</span><span class="dt">real_type</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="kw">using</span> <span class="dt">rng_state_type</span> <span class="op">=</span> dust<span class="op">::</span>random<span class="op">::</span>generator<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;</span> <span class="dt">rng_state_type</span><span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>  <span class="kw">using</span> <span class="dt">data_type</span> <span class="op">=</span> dust<span class="op">::</span>no_data<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>  <span class="kw">struct</span> <span class="dt">shared_type</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    <span class="dt">real_type</span> initial_y<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>    <span class="dt">real_type</span> sd<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>  <span class="kw">struct</span> <span class="dt">internal_type</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>  odin<span class="op">(</span><span class="at">const</span> dust<span class="op">::</span><span class="dt">pars_type</span><span class="op">&lt;</span>odin<span class="op">&gt;&amp;</span> pars<span class="op">)</span> <span class="op">:</span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>    shared<span class="op">(</span>pars<span class="op">.</span>shared<span class="op">),</span> internal<span class="op">(</span>pars<span class="op">.</span>internal<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>  <span class="dt">size_t</span> size<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;</span> initial<span class="op">(</span><span class="dt">size_t</span> time<span class="op">,</span> <span class="dt">rng_state_type</span><span class="op">&amp;</span> rng_state<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;</span> state<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>    state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> shared<span class="op">-&gt;</span>initial_y<span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>    <span class="cf">return</span> state<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a>  <span class="dt">void</span> update<span class="op">(</span><span class="dt">size_t</span> time<span class="op">,</span> <span class="at">const</span> <span class="dt">real_type</span> <span class="op">*</span> state<span class="op">,</span> <span class="dt">rng_state_type</span><span class="op">&amp;</span> rng_state<span class="op">,</span> <span class="dt">real_type</span> <span class="op">*</span> state_next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">real_type</span> y <span class="op">=</span> state<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>    state_next<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dust<span class="op">::</span>random<span class="op">::</span>uniform<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;(</span>rng_state<span class="op">,</span> y<span class="op">,</span> shared<span class="op">-&gt;</span>sd<span class="op">);</span></span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a>  <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="at">const</span> <span class="dt">shared_type</span><span class="op">&gt;</span> shared<span class="op">;</span></span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a>  <span class="dt">internal_type</span> internal<span class="op">;</span></span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a><span class="co">// ...[some utility code excluded]</span></span>
<span id="cb9-36"><a href="#cb9-36" tabindex="-1"></a>dust<span class="op">::</span><span class="dt">pars_type</span><span class="op">&lt;</span>odin<span class="op">&gt;</span> dust_pars<span class="op">&lt;</span>odin<span class="op">&gt;(</span>cpp11<span class="op">::</span>list user<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-37"><a href="#cb9-37" tabindex="-1"></a>  <span class="kw">using</span> <span class="dt">real_type</span> <span class="op">=</span> <span class="kw">typename</span> odin<span class="op">::</span><span class="dt">real_type</span><span class="op">;</span></span>
<span id="cb9-38"><a href="#cb9-38" tabindex="-1"></a>  <span class="kw">auto</span> shared <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>odin<span class="op">::</span><span class="dt">shared_type</span><span class="op">&gt;();</span></span>
<span id="cb9-39"><a href="#cb9-39" tabindex="-1"></a>  odin<span class="op">::</span><span class="dt">internal_type</span> internal<span class="op">;</span></span>
<span id="cb9-40"><a href="#cb9-40" tabindex="-1"></a>  shared<span class="op">-&gt;</span>initial_y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-41"><a href="#cb9-41" tabindex="-1"></a>  shared<span class="op">-&gt;</span>sd <span class="op">=</span> NA_REAL<span class="op">;</span></span>
<span id="cb9-42"><a href="#cb9-42" tabindex="-1"></a>  shared<span class="op">-&gt;</span>sd <span class="op">=</span> user_get_scalar<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;(</span>user<span class="op">,</span> <span class="st">"sd"</span><span class="op">,</span> shared<span class="op">-&gt;</span>sd<span class="op">,</span> NA_REAL<span class="op">,</span> NA_REAL<span class="op">);</span></span>
<span id="cb9-43"><a href="#cb9-43" tabindex="-1"></a>  <span class="cf">return</span> dust<span class="op">::</span><span class="dt">pars_type</span><span class="op">&lt;</span>odin<span class="op">&gt;(</span>shared<span class="op">,</span> internal<span class="op">);</span></span>
<span id="cb9-44"><a href="#cb9-44" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We have designed these two systems to play well together so the user
can write models at a very high level and generate code that then works
well within this framework and efficiently run in parallel. In <a href="https://mrc-ide.github.io/sircovid/" class="external-link">sircovid</a> this is used in
a model with hundreds of logical compartments each of which may be
structured, but the interface at the R level remains the same as for the
toy models used in the documentation here.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Rich FitzJohn, Alex Hill, John Lees.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

      </footer>
</div>






  </body>
</html>
