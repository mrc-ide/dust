% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interface.R
\name{dust_generate}
\alias{dust_generate}
\title{Generate dust code}
\usage{
dust_generate(
  filename,
  quiet = FALSE,
  workdir = NULL,
  gpu = FALSE,
  real_type = NULL,
  linking_to = NULL,
  cpp_std = NULL,
  compiler_options = NULL,
  optimisation_level = NULL,
  mangle = FALSE
)
}
\arguments{
\item{filename}{The path to a single C++ file}

\item{quiet}{Logical, indicating if compilation messages from
\code{pkgbuild} should be displayed.  Error messages will be
displayed on compilation failure regardless of the value used.}

\item{workdir}{Optional working directory to use.  If \code{NULL}
uses a temporary directory.  By using a different directory of
your choosing you can see the generated code.}

\item{gpu}{Logical, indicating if we should generate GPU
code. This requires a considerable amount of additional software
installed (CUDA toolkit and drivers) as well as a
CUDA-compatible GPU. If \code{TRUE}, then we call
\link{dust_cuda_options} with no arguments. Alternatively, call
that function and pass the value here (e.g, \code{gpu = dust::dust_cuda_options(debug = TRUE)}). Note that due to the
use of the \verb{__syncwarp()} primitive this may require a GPU with
compute version 70 or higher.}

\item{real_type}{Optionally, a string indicating a substitute type to
swap in for your model's \code{real_type} declaration. If given, then we
replace the string \verb{using real_type = (double|float)} with the
given type. This is primarily intended to be used as \verb{gpu = TRUE, real_type = "float"} in order to create model for the GPU
that will use 32 bit \code{floats} (rather than 64 bit doubles, which
are much slower). For CPU models decreasing precision of your
real type will typically just decrease precision for no
additional performance.}

\item{linking_to}{Optionally, a character vector of additional
packages to add to the \code{DESCRIPTION}'s \code{LinkingTo} field. Use
this when your model pulls in C++ code that is packaged within
another package's header-only library.}

\item{cpp_std}{The C++ standard to use, if you need to set one
explicitly. See the section "Using C++ code" in "Writing R
extensions" for the details of this, and how it interacts with
the R version currently being used. For R 4.0.0 and above, C++11
will be used; as dust depends on at least this version of R you
will never need to specify a version this low. Sensible options
are \code{C++14}, \code{C++17}, etc, depending on the features you need
and what your compiler supports.}

\item{compiler_options}{A character vector of additional options
to pass through to the C++ compiler. These will be passed
through without any shell quoting or validation, so check the
generated commands and outputs carefully in case of error. Note
that R will apply these \emph{before} anything in your personal
\code{Makevars}.}

\item{optimisation_level}{A shorthand way of specifying common
compiler options that control optimisation level. By default
(\code{NULL}) no options are generated from this, and the
optimisation level will depend on your user \code{Makevars} file.
Valid options are \code{none} which disables optimisation (\code{-O0}),
which will be faster to compile but much slower, \code{standard}
which enables standard level of optimisation (\code{-O2}), useful if
your Makevars/pkgload configuration is disabling optimisation,
or \code{max} (\code{-O3} and \code{--fast-math}) which enables some
slower-to-compile and \href{https://simonbyrne.github.io/notes/fastmath/}{potentially unsafe}
optimisations.  These options are applied \emph{after}
\code{compiler_options} and may override options provided there.
Note that as for \code{compiler_options}, R will apply these \emph{before}
anything in your personal \code{Makevars}}

\item{mangle}{Logical, indicating if the model name should be
mangled when creating the package. This is safer if you will
load multiple copies of the package into a single session, but
is \code{FALSE} by default as the generated code is easier to read.}
}
\value{
The path to the generated package (will be \code{workdir} if
that was provided, otherwise a temporary directory).
}
\description{
Generate a package out of a dust model. The resulting package can
be installed or loaded via \code{pkgload::load_all()} though it
contains minimal metadata and if you want to create a persistent
package you should use \code{\link[=dust_package]{dust_package()}}.  This function is
intended for cases where you either want to inspect the code or
generate it once and load multiple times (useful in some workflows
with CUDA models).
}
\examples{
filename <- system.file("examples/walk.cpp", package = "dust")
path <- dust::dust_generate(filename)

# Simple package created:
dir(path)
dir(file.path(path, "R"))
dir(file.path(path, "src"))
}
