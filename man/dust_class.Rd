% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dust_class.R
\name{dust_class}
\alias{dust_class}
\title{The dust class}
\description{
All "dust" dust models are really \link[R6:R6Class]{R6} objects and
expose the same set of "methods".  To create a dust model of
your own, see \link{dust} and to interact with some built-in
ones see \code{\link[=dust_example]{dust_example()}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dust_class$new()}}
\item \href{#method-name}{\code{dust_class$name()}}
\item \href{#method-param}{\code{dust_class$param()}}
\item \href{#method-run}{\code{dust_class$run()}}
\item \href{#method-simulate}{\code{dust_class$simulate()}}
\item \href{#method-set_index}{\code{dust_class$set_index()}}
\item \href{#method-index}{\code{dust_class$index()}}
\item \href{#method-n_threads}{\code{dust_class$n_threads()}}
\item \href{#method-n_state}{\code{dust_class$n_state()}}
\item \href{#method-n_particles}{\code{dust_class$n_particles()}}
\item \href{#method-n_particles_each}{\code{dust_class$n_particles_each()}}
\item \href{#method-shape}{\code{dust_class$shape()}}
\item \href{#method-set_state}{\code{dust_class$set_state()}}
\item \href{#method-reset}{\code{dust_class$reset()}}
\item \href{#method-set_pars}{\code{dust_class$set_pars()}}
\item \href{#method-state}{\code{dust_class$state()}}
\item \href{#method-step}{\code{dust_class$step()}}
\item \href{#method-reorder}{\code{dust_class$reorder()}}
\item \href{#method-resample}{\code{dust_class$resample()}}
\item \href{#method-info}{\code{dust_class$info()}}
\item \href{#method-pars}{\code{dust_class$pars()}}
\item \href{#method-rng_state}{\code{dust_class$rng_state()}}
\item \href{#method-set_rng_state}{\code{dust_class$set_rng_state()}}
\item \href{#method-has_openmp}{\code{dust_class$has_openmp()}}
\item \href{#method-has_cuda}{\code{dust_class$has_cuda()}}
\item \href{#method-n_pars}{\code{dust_class$n_pars()}}
\item \href{#method-set_n_threads}{\code{dust_class$set_n_threads()}}
\item \href{#method-has_compare}{\code{dust_class$has_compare()}}
\item \href{#method-set_data}{\code{dust_class$set_data()}}
\item \href{#method-compare_data}{\code{dust_class$compare_data()}}
\item \href{#method-filter}{\code{dust_class$filter()}}
\item \href{#method-device_info}{\code{dust_class$device_info()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new model. Note that the behaviour of this object
created by this function will change considerably based on
whether the \code{pars_multi} argument is \code{TRUE}. If not (the
default) then we create \code{n_particles} which all share the same
parameters as specified by the \code{pars} argument. If \code{pars_multi}
is \code{TRUE} then \code{pars} must be an unnamed list, and each element
of it represents a different set of parameters. We will
create \code{length(pars)} \emph{sets} of \code{n_particles} particles which
will be simulated together. These particles must have the same
dimension - that is, they must correspond to model state that
is the same size.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$new(
  pars,
  step,
  n_particles,
  n_threads = 1L,
  seed = NULL,
  pars_multi = FALSE,
  device_config = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{Data to initialise your model with; a \code{list}
object, but the required elements will depend on the details of
your model. If \code{pars_multi} is \code{TRUE}, then this must be an
\emph{unnamed} list of \code{pars} objects (see Details).}

\item{\code{step}}{Initial step - must be nonnegative}

\item{\code{n_particles}}{Number of particles to create - must be at
least 1}

\item{\code{n_threads}}{Number of OMP threads to use, if \code{dust} and
your model were compiled with OMP support (details to come).
\code{n_particles} should be a multiple of \code{n_threads} (e.g., if you use 8
threads, then you should have 8, 16, 24, etc particles). However, this
is not compulsory.}

\item{\code{seed}}{The seed to use for the random number generator. Can
be a positive integer, \code{NULL} (initialise with R's random number
generator) or a \code{raw} vector of a length that is a multiple of
32 to directly initialise the generator (e..g., from the
\code{\link{dust}} object's \verb{$rng_state()} method).}

\item{\code{pars_multi}}{Logical, indicating if \code{pars} should be
interpreted as a set of different initialisations, and that we
should prepare \code{n_particles * length(pars)} particles for
simulation. This has an effect on many of the other methods of
the object.}

\item{\code{device_config}}{Device configuration, typically an integer
indicating the device to use, where the model has GPU support.
If not given, then the default value of \code{NULL} will fall back on the
first found device if any are available. An error is thrown if the
device id given is larger than those reported to be available (note
that CUDA numbers devices from 0, so that '0' is the first device,
and so on). Negative values disable the use of a device. See the
method \verb{$device_info()} for available device ids; this can be called
before object creation as \code{dust_class$public_methods$device_info()}.
For additional control, provide a list with elements \code{device_id}
and \code{run_block_size}. Further options (and validation) of this
list will be added in a future version!}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-name"></a>}}
\if{latex}{\out{\hypertarget{method-name}{}}}
\subsection{Method \code{name()}}{
Returns friendly model name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$name()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-param"></a>}}
\if{latex}{\out{\hypertarget{method-param}{}}}
\subsection{Method \code{param()}}{
Returns parameter information, if provided by the model. This
describes the contents of pars passed to the constructor or to
\code{reset} as the \code{pars} argument, and the details depend on the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$param()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
Run the model up to a point in time, returning the filtered state
at that point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$run(step_end, device = FALSE, deterministic = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{Step to run to (if less than or equal to the current
step(), silently nothing will happen)}

\item{\code{device}}{\strong{Experimental!}: This argument may allow running on
a GPU once support is finished, if the model supports it, and if
the model is compiled appropriately (and assuming you have a
suitable GPU). At present it exists for testing and will run
slower than running with \code{device = TRUE}. The interpretation of
this argument will likely change to allow selecting the GPU on
systems with more than one. In short, please leave this argument
alone unless you're developing dust.}

\item{\code{deterministic}}{Run random number generation deterministically,
replacing a random number from some distribution with its
expectation.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-simulate"></a>}}
\if{latex}{\out{\hypertarget{method-simulate}{}}}
\subsection{Method \code{simulate()}}{
Iterate all particles forward in time over a series of steps,
collecting output as they go. This is a helper around \verb{$run()}
where you want to run to a series of points in time and save
output. The returned object will be filtered by your active index,
so that it has shape (\code{n_state} x \code{n_particles} x \code{length(step_end)})
for single-parameter objects, and (\code{n_state} x \code{n_particles} x
\code{n_pars} x \code{length(step_end)}) for multiparameter objects. Note that
this method is very similar to \verb{$run()} except that the rank of
the returned array is one less. For a scalar \code{step_end} you would
ordinarily want to use \verb{$run()} but the resulting numbers would
be identical.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$simulate(step_end, device = FALSE, deterministic = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{A vector of time points that the simulation should
report output at. This the first time must be at least the same
as the current time, and every subsequent time must be equal or
greater than those before it (ties are allowed though probably
not wanted).}

\item{\code{device}}{\strong{Experimental!}: This argument may allow running on
a GPU once support is finished, if the model supports it, and if
the model is compiled appropriately (and assuming you have a
suitable GPU). At present it exists for testing and will run
slower than running with \code{device = TRUE}. The interpretation of
this argument will likely change to allow selecting the GPU on
systems with more than one. In short, please leave this argument
alone unless you're developing dust.}

\item{\code{deterministic}}{Run random number generation deterministically,
replacing a random number from some distribution with its
expectation.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_index"></a>}}
\if{latex}{\out{\hypertarget{method-set_index}{}}}
\subsection{Method \code{set_index()}}{
Set the "index" vector that is used to return a subset of pars
after using \code{run()}. If this is not used then \code{run()} returns
all elements in your state vector, which may be excessive and slower
than necessary. This method must be called after any
call to \code{reset()} as \code{reset()} may change the size of the state
and that will invalidate the index.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_index(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{The index vector - must be an integer vector with
elements between 1 and the length of the state (this will be
validated, and an error thrown if an invalid index is given).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-index"></a>}}
\if{latex}{\out{\hypertarget{method-index}{}}}
\subsection{Method \code{index()}}{
Returns the \code{index} as set by \verb{$set_index}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$index()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_threads"></a>}}
\if{latex}{\out{\hypertarget{method-n_threads}{}}}
\subsection{Method \code{n_threads()}}{
Returns the number of threads that the model was constructed with
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_threads()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_state"></a>}}
\if{latex}{\out{\hypertarget{method-n_state}{}}}
\subsection{Method \code{n_state()}}{
Returns the length of the per-particle state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_state()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_particles"></a>}}
\if{latex}{\out{\hypertarget{method-n_particles}{}}}
\subsection{Method \code{n_particles()}}{
Returns the number of particles
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_particles()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_particles_each"></a>}}
\if{latex}{\out{\hypertarget{method-n_particles_each}{}}}
\subsection{Method \code{n_particles_each()}}{
Returns the number of particles per parameter set
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_particles_each()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-shape"></a>}}
\if{latex}{\out{\hypertarget{method-shape}{}}}
\subsection{Method \code{shape()}}{
Returns the shape of the particles
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$shape()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_state}{}}}
\subsection{Method \code{set_state()}}{
Set the "state" vector for all particles, overriding whatever your
models \code{initial()} method provides.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_state(state, step = NULL, deterministic = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{The state vector - can be either a numeric vector with the
same length as the model's current state (in which case the same
state is applied to all particles), or a numeric matrix with as
many rows as your model's state and as many columns as you have
particles (in which case you can set a number of different starting
states at once).}

\item{\code{step}}{If not \code{NULL}, then this sets the initial step. If this
is a vector (with the same length as the number of particles), then
particles are started from different initial steps and run up to the
largest step given (i.e., \code{max(step)})}

\item{\code{deterministic}}{If \code{TRUE} and if \code{step} is a vector with
different values, then this would run up to the largest step
deterministically (see \verb{$run()} for more details).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Reset the model while preserving the random number stream state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reset(pars, step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{New pars for the model (see constructor)}

\item{\code{step}}{New initial step for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_pars"></a>}}
\if{latex}{\out{\hypertarget{method-set_pars}{}}}
\subsection{Method \code{set_pars()}}{
Set the 'pars' element in a dust object while holding model state,
index, etc constant. In contrast to \verb{$reset}, the old state must
be compatible with the new one (e.g., don't change model size), and
the index will remain valid.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_pars(pars)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{New pars for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Return full model state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$state(index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Optional index to select state using}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-step"></a>}}
\if{latex}{\out{\hypertarget{method-step}{}}}
\subsection{Method \code{step()}}{
Return current model step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$step()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-reorder}{}}}
\subsection{Method \code{reorder()}}{
Reorder particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reorder(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{An integer vector, with values between 1 and n_particles,
indicating the index of the current particles that new particles should
take.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-resample"></a>}}
\if{latex}{\out{\hypertarget{method-resample}{}}}
\subsection{Method \code{resample()}}{
Resample particles according to some weight.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$resample(weights)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{weights}}{A numeric vector representing particle weights.
For a "multi-parameter" dust object this should be be a matrix
with the number of rows being the number of particles per
parameter set and the number of columns being the number of
parameter sets.
long as all particles or be a matrix.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\if{latex}{\out{\hypertarget{method-info}{}}}
\subsection{Method \code{info()}}{
Returns information about the pars that your model was created with.
Only returns non-NULL if the model provides a \code{dust_info} template
specialisation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$info()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pars"></a>}}
\if{latex}{\out{\hypertarget{method-pars}{}}}
\subsection{Method \code{pars()}}{
Returns the \code{pars} object that your model was constructed with.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$pars()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rng_state"></a>}}
\if{latex}{\out{\hypertarget{method-rng_state}{}}}
\subsection{Method \code{rng_state()}}{
Returns the state of the random number generator. This returns a
raw vector of length 32 * n_particles. This can be useful for
debugging or for initialising other dust objects. The arguments
\code{first_only} and \code{last_only} are mutally exclusive. If neither is
given then all all particles states are returned, being 32 bytes
per particle. The full returned state or \code{first_only} are most
suitable for reseeding a new dust object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$rng_state(first_only = FALSE, last_only = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{first_only}}{Logical, indicating if we should return only the
first random number state}

\item{\code{last_only}}{Logical, indicating if we should return only the
\emph{last} random number state, which does not belong to a particle.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_rng_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_rng_state}{}}}
\subsection{Method \code{set_rng_state()}}{
Set the random number state for this model. This
replaces the RNG state that the model is using with a state of
your choosing, saved out from a different model object. This method
is designed to support advanced use cases where it is easier to
manipulate the state of the random number generator than the
internal state of the dust object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_rng_state(rng_state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rng_state}}{A random number state, as saved out by the
\verb{$rng_state()} method. Note that unlike \code{seed} as passed to the
constructor, this \emph{must} be a raw vector of the expected length.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_openmp"></a>}}
\if{latex}{\out{\hypertarget{method-has_openmp}{}}}
\subsection{Method \code{has_openmp()}}{
Returns a logical, indicating if this model was compiled with
"OpenMP" support, in which case it will react to the \code{n_threads}
argument passed to the constructor. This method can also be used
as a static method by running it directly
as \code{dust_class$public_methods$has_openmp()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$has_openmp()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_cuda"></a>}}
\if{latex}{\out{\hypertarget{method-has_cuda}{}}}
\subsection{Method \code{has_cuda()}}{
Returns a logical, indicating if this model was compiled with
"CUDA" support, in which case it will react to the \code{device}
argument passed to the run method. This method can also be used
as a static method by running it directly
as \code{dust_class$public_methods$has_cuda()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$has_cuda()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_pars"></a>}}
\if{latex}{\out{\hypertarget{method-n_pars}{}}}
\subsection{Method \code{n_pars()}}{
Returns the number of distinct pars elements required. This is \code{0}
where the object was initialised with \code{pars_multi = FALSE} and
an integer otherwise.  For multi-pars dust objects, Where \code{pars}
is accepted, you must provide an unnamed list of length \verb{$n_pars()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_pars()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_n_threads"></a>}}
\if{latex}{\out{\hypertarget{method-set_n_threads}{}}}
\subsection{Method \code{set_n_threads()}}{
Change the number of threads that the dust object will use. Your
model must be compiled with "OpenMP" support for this to have an
effect. Returns (invisibly) the previous value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_n_threads(n_threads)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_threads}}{The new number of threads to use. You may want to
wrap this argument in \code{\link[=dust_openmp_threads]{dust_openmp_threads()}} in order to
verify that you can actually use the number of threads
requested (based on environment variables and OpenMP support).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_compare"></a>}}
\if{latex}{\out{\hypertarget{method-has_compare}{}}}
\subsection{Method \code{has_compare()}}{
Returns a logical, indicating if this model was compiled with
"compare" support, in which case the \code{set_data} and \code{compare_data}
methods are available (otherwise these methods will error). This
method can also be used as a static method by running it directly
as \code{dust_class$public_methods$has_compare()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$has_compare()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_data"></a>}}
\if{latex}{\out{\hypertarget{method-set_data}{}}}
\subsection{Method \code{set_data()}}{
Set "data" into the model for use with the \verb{$compare_data()} method.
This is not supported by all models, depending on if they define a
\code{data_t} type.  See \code{\link[=dust_data]{dust_data()}} for a helper function to
construct suitable data and a description of the required format. You
will probably want to use that here, and definitely if using multiple
parameter sets.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_data(data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{A list of data to set.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compare_data"></a>}}
\if{latex}{\out{\hypertarget{method-compare_data}{}}}
\subsection{Method \code{compare_data()}}{
Compare the current model state against the data as set by
\code{set_data}. If there is no data set, or no data corresponding to
the current time then \code{NULL} is returned. Otherwise a numeric vector
the same length as the number of particles is returned. If model's
underlying \code{compare_data} function is stochastic, then each call to
this function may be result in a different answer.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$compare_data(device = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{device}}{\strong{Experimental!}: This argument may allow running on
a GPU once support is finished, if the model supports it, and if
the model is compiled appropriately (and assuming you have a
suitable GPU). At present it exists for testing and will run
slower than running with \code{device = FALSE}. The interpretation of
this argument will likely change to allow selecting the GPU on
systems with more than one. In short, please leave this argument
alone unless you're developing dust.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-filter"></a>}}
\if{latex}{\out{\hypertarget{method-filter}{}}}
\subsection{Method \code{filter()}}{
Run a particle filter. The interface here will change a lot over the
next few versions. You \emph{must} \verb{$reset()} the filter before using
this method to get sensible values. We will tinker with this in
future versions to allow things like partial runs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$filter(
  save_trajectories = FALSE,
  step_snapshot = NULL,
  device = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{save_trajectories}}{Logical, indicating if the filtered particle
trajectories should be saved. If \code{TRUE} then the \code{trajectories} element
will be a multidimensional array (\verb{state x <shape> x time})
containing the state values, selected according to the index set
with \verb{$set_index()}.}

\item{\code{step_snapshot}}{Optional integer vector indicating steps
that we should record a snapshot of the full particle filter state.
If given it must be strictly increasing vector whose elements
match steps given in the \code{data} object. The return value with be
a multidimensional array (\verb{state x <shape> x step_snapshot})
containing full state values at the requested steps.}

\item{\code{device}}{\strong{Experimental!}: This argument may allow running on
a GPU once support is finished, if the model supports it, and if
the model is compiled appropriately (and assuming you have a
suitable GPU). At present it exists for testing and will run
slower than running with \code{device = FALSE}. The interpretation of
this argument will likely change to allow selecting the GPU on
systems with more than one. In short, please leave this argument
alone unless you're developing dust.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-device_info"></a>}}
\if{latex}{\out{\hypertarget{method-device_info}{}}}
\subsection{Method \code{device_info()}}{
\strong{Experimental!} Return information about GPU devices, if the model
has been compiled with CUDA/GPU support. This can be called as a
static method by running \code{dust_class$public_methods$device_info()}.
If run from a GPU enabled object, it will also have an element
\code{config} containing the computed device configuration: the device
id, shared memory and the block size for the \code{run} method on the
device.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$device_info()}\if{html}{\out{</div>}}
}

}
}
