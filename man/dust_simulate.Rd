% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate.R
\name{dust_simulate}
\alias{dust_simulate}
\title{Simulate from a dust model generator}
\usage{
dust_simulate(
  model,
  steps,
  pars,
  state,
  index = NULL,
  n_threads = 1L,
  seed = NULL,
  return_state = FALSE
)
}
\arguments{
\item{model}{A \link{dust} model generator object}

\item{steps}{The vector of steps used to simulate over. The first
step in this vector is the starting step (corresponding to the
initial \code{state} of the model) and subsequent values are steps
where state should be returned.}

\item{pars}{An unnamed list of model initialisation pars (see
\link{dust}).  It must have the same length as the number of columns
in \code{state}.}

\item{state}{A matrix of initial states. It must have the number
of rows corresponding to the number of initial state values your
model requires, and the number of columns corresponding to the
number of independent simulations to perform (i.e.,
\code{length(pars)}).}

\item{index}{An optional index, indicating the indices of the
state vectors that you want output recorded for.}

\item{n_threads}{Number of OMP threads to use, if \code{dust} and your
model were compiled with OMP support.  The number of simulations
(\code{length(pars)}) should be a multiple of \code{n_threads} (e.g., if
you use 8 threads, then you should have 8, 16, 24, etc
particles). However, this is not compulsory.}

\item{seed}{The seed to use for the random number generator. Can
be a positive integer, \code{NULL} (initialise with R's random number
generator) or a \code{raw} vector of a length that is a multiple of
32 to directly initialise the generator (e.g., from the
\code{\link{dust}} object's \verb{$rng_state()} method).}

\item{return_state}{Logical, indicating if the final state should
be returned. If \code{TRUE}, then an attribute \code{state} with the same
dimensions as the input \code{state} will be added to the array,
along with an attribute \code{rng_state} with the internal state of
the random number generator.}
}
\description{
Simulate a dust model.  This function is deprecated since v0.7.8
and will be removed in a future version of dust. Please use the
\verb{$simulate()} method directly on a dust object - see below for
details to update your code.
}
\details{
This function was designed to support the special case of
simulating a set of trajectories across a list of parameters and
initial state. Now that \link{dust} models support multiple parameters
natively this is deprecated.

To migrate to use the method, initialise your model with the list
of parameters, like:\preformatted{mod <- model$new(pars, steps[[1]], 1L)
mod$set_state(state)
mod$set_index(index) # if using
}

In contrast to this function the 3rd argument there can be used to
simulate multiple trajectories \emph{per} parameter set. You can set
\code{n_threads} and \code{seed} as in the constructor as normal.

Now you can run the model with\preformatted{y <- mod$simulate(steps)
}

which will return a 4d matrix (in this case with 1 trajectory per
parameter set.

The advantage of this approach over the previous \code{dust_simulate}
approach is that now you can inspect your model to get state,
continue it etc without having to worry about the rng state; it
should be much more flexible.
}
\examples{
# Use the "random walk" example
model <- dust::dust_example("walk")

# Start with 40 parameter sets; for this model each is list with
# an element 'sd'
pars <- replicate(40, list(sd = runif(1)), simplify = FALSE)
mod <- model$new(pars, 0, 1, pars_multi = TRUE)

# We also need an array of initial states
y0 <- array(rnorm(40), c(1, 1, 40))
mod$set_state(y0)

# Run from steps 0..50
steps <- 0:50

# The simulated output:
res <- mod$simulate(steps)

# The result of the simulation, plotted over time
matplot(steps, t(drop(res)), type = "l", col = "#00000055", lty = 1,
        xlab = "Time", ylab = "Value")
}
