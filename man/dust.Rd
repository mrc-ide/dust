% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dust.R, R/interface.R
\name{dust}
\alias{dust}
\alias{dust_interface}
\title{Create a dust model from a C++ input file}
\usage{
dust(filename, type = NULL, name = NULL, quiet = FALSE, workdir = NULL)
}
\arguments{
\item{filename}{The path to a single C++ file}

\item{type}{The name of the "type" (the C++ class) that represents
your model.  If \code{NULL} we try to work this out from your
file using extremely simple heuristics.}

\item{name}{The name of the model; for technical reasons this must
be alphanumeric characters only (sorry, no underscore) and must
not start with a number.  If \code{NULL} the value of
\code{type} will be used.}

\item{quiet}{Logical, indicating if compilation messages from
\code{pkgbuild} should be displayed.  Error messages will be
displayed on compilation failure regardless of the value used.}

\item{workdir}{Optional working directory to use.  If \code{NULL}
uses a temporary directory.  By using a different directory of
your choosing you can see the generated code.}
}
\description{
Create a dust model from a C++ input file.  This function will
compile the dust support around your model and return an object
that can be used to work with the model (see the Details below).
}
\section{Input requirements}{


Your input dust model must satisfy a few requirements.
\itemize{
\item Define some class that implements your model (below \code{model} is
assumed to be the class name)
\item That class must define a type \code{init_t} (so \code{model::init_t}) that
contains its internal data and the model must be constructable
with a const reference to this type (\verb{const model::init_t& data})
\item That class must also include typedefs that describe the standard
floating point and integer types (\code{real_t} and \code{int_t}
respectively). Most models can include \verb{typedef double real_t;}
and \verb{typedef int int_t;} in their public section.
\item The model must have a method \code{size()} returning \code{size_t} which
returns the size of the system. This size may depend on values
in your initialisation object but is constant within a model
run.
\item The model must have a method \code{update} (which may not be
\code{const}), taking a step number (\code{size_t}) and returning a
\verb{std::vector<real_t>} of initial state for the model.
\item The model must have a method \code{update} taking arguments:
\itemize{
\item \verb{size_t step}: the step number
\item \verb{const std::vector<real_t>& state}: the state at the beginning of the
step
\item \verb{dust::RNG<real_t, int_t>& rng}: the dust random number generator
\item \verb{std::vector<real_t>& state_next}: the end state of the model
(to be written to by your function)
}
}

Your \code{update} function is the core here and should update the
state of the system - you are expected to update all values of
\code{state} on return.

It is very important that none of the functions in the class use
the R API in any way as these functions will be called in
parallel.

You must also provide a data-wrangling function for producing an
object of type \code{model::init_t} from an R list.  We use Rcpp for
this.  Your function will look like:\preformatted{template <>
model::init_t dust_data<model>(Rcpp::List data) \{
  return ...;
\}
}

With the body interacting with \code{data} to create an object of type
\code{model::init_t} and returning it.  This function will be called
in serial and may use anything in the Rcpp API.  All elements of
the returned object must be standard C/C++ (e.g., STL) types and
\emph{not} Rcpp types.

Your model \emph{may} provided a template specialisation
\verb{dust_data<model::init_t>()} returning a \code{Rcpp::RObject} for
returning arbitrary information back to the R session:\preformatted{template <>
Rcpp::RObject dust_info<model>(const model::init_t& data) \{
  return Rcpp::wrap(...);
\}
}

What you do with this is up to you. If not present then the
\code{info()} method on the created object will return \code{NULL}.
Potential use cases for this are to return information about
variable ordering, or any processing done while accepting the
data object used to create the data fed into the particles.
}

\examples{

# dust includes a couple of very simple examples
filename <- system.file("examples/walk.cpp", package = "dust")

# This model implements a random walk with a parameter coming from
# R representing the standard deviation of the walk
writeLines(readLines(filename))

# Compile and load the object:
model <- dust(filename, quiet = TRUE)

# Print the object and you can see the methods that it provides
model

# Create a model with standard deviation of 1, initial step zero
# and 30 particles
obj <- model$new(list(sd = 1), 0, 30)
obj

# Curent state is all zero
obj$state()

# Current step is also zero
obj$step()

# Run the model up to step 100
obj$run(100)

# Reorder/resample the particles:
obj$reorder(sample(30, replace = TRUE))

# See the state again
obj$state()
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dust_interface$new()}}
\item \href{#method-run}{\code{dust_interface$run()}}
\item \href{#method-set_index}{\code{dust_interface$set_index()}}
\item \href{#method-set_state}{\code{dust_interface$set_state()}}
\item \href{#method-reset}{\code{dust_interface$reset()}}
\item \href{#method-state}{\code{dust_interface$state()}}
\item \href{#method-step}{\code{dust_interface$step()}}
\item \href{#method-reorder}{\code{dust_interface$reorder()}}
\item \href{#method-info}{\code{dust_interface$info()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$new(
  data,
  step,
  n_particles,
  n_threads = 1L,
  n_generators = 1L,
  seed = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{Data to initialise your model with; a \code{list}
object, but the required elements will depend on the details of
your model.}

\item{\code{step}}{Initial step - must be nonnegative}

\item{\code{n_particles}}{Number of particles to create - must be at
least 1}

\item{\code{n_threads}}{Number of OMP threads to use, if \code{dust} and
your model were compiled with OMP support (details to come)}

\item{\code{n_generators}}{The number of random number generators to
use. Must be at least \code{n_threads} and a multiple of
\code{n_threads}.  You can use this to ensure reproducible results
when changing the number of threads, while preserving
statistically reasonable random numbers (for example setting
\code{n_generators = 64} and then using 1, 2, 4, 8, ..., 64 threads
as your computational capacity allows).}

\item{\code{seed}}{Seed to use for the random number generator
(positive integer)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
Run the model up to a point in time, returning the filtered state
at that point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$run(step_end)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{Step to run to (if less than or equal to the current
step(),silently nothing will happen)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_index"></a>}}
\if{latex}{\out{\hypertarget{method-set_index}{}}}
\subsection{Method \code{set_index()}}{
Set the "index" vector that is used to return a subset of data
after using \code{run()}. If this is not used then \code{run()} returns
all elements in your state vector, which may be excessive and slower
than necessary. This method must be called after any
call to \code{reset()} as \code{reset()} may change the size of the state
and that will invalidate the index.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$set_index(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{The index vector - must be an integer vector with
elements between 1 and the length of the state (this will be
validated, and an error thrown if an invalid index is given).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_state}{}}}
\subsection{Method \code{set_state()}}{
Set the "state" vector for all particles, overriding whatever your
models \code{initial()} method provides. Currently all particles are set
to the same state.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$set_state(state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{The state vector - must be a numeric vector with the
same length as the model's current state.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Reset the model while preserving the random number stream state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$reset(data, step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{New data for the model (see constructor)}

\item{\code{step}}{New initial step for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Return full model state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$state(index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Optional index to select state using}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-step"></a>}}
\if{latex}{\out{\hypertarget{method-step}{}}}
\subsection{Method \code{step()}}{
Return current model step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$step()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-reorder}{}}}
\subsection{Method \code{reorder()}}{
Reorder or resample particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$reorder(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{An integer vector, with values between 1 and n_particles,
indicating the index of the current particles that new particles should
take.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\if{latex}{\out{\hypertarget{method-info}{}}}
\subsection{Method \code{info()}}{
Returns information about the data that your model was created with.
Only returns non-NULL if the model provides a \code{dust_info} template
specialisation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$info()}\if{html}{\out{</div>}}
}

}
}
