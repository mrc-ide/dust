% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interface.R
\name{dust}
\alias{dust}
\alias{dust_interface}
\title{Create a dust model from a C++ input file}
\usage{
dust(filename, type = NULL, name = NULL, quiet = FALSE, workdir = NULL)
}
\arguments{
\item{filename}{The path to a single C++ file}

\item{type}{The name of the "type" (the C++ class) that represents
your model.  If \code{NULL} we try to work this out from your
file using extremely simple heuristics.}

\item{name}{The name of the model; for technical reasons this must
be alphanumeric characters only (sorry, no underscore) and must
not start with a number.  If \code{NULL} the value of
\code{type} will be used.}

\item{quiet}{Logical, indicating if compilation messages from
\code{pkgbuild} should be displayed.  Error messages will be
displayed on compilation failure regardless of the value used.}

\item{workdir}{Optional working directory to use.  If \code{NULL}
uses a temporary directory.  By using a different directory of
your choosing you can see the generated code.}
}
\description{
Create a dust model from a C++ input file.  This function will
compile the dust support around your model and return an object
that can be used to work with the model (see the Details below).
}
\section{Input requirements}{


Your input dust model must satisfy a few requirements.
\itemize{
\item Define some class that implements your model (below \code{model} is
assumed to be the class name)
\item That class must define a type \code{init_t} (so \code{model::init_t}) that
contains its internal data and the model must be constructable
with a const reference to this type (\verb{const model::init_t& data})
\item The model must have a method \code{size()} returning \code{size_t} which
returns the size of the system. This size may depend on values
in your initialisation object but is constant within a model
run.
\item The model must have a method \code{update} (which may not be
\code{const}), taking a step number (\code{size_t}) and returning a
\verb{std::vector<double>} of initial state for the model.
\item The model must have a method \code{update} taking arguments:
\itemize{
\item \verb{size_t step}: the step number
\item \verb{const std::vector<double>& state}: the state at the beginning of the
step
\item \code{dust::RNG& rng}: the dust random number generator
\item \verb{std::vector<double>& state_next}: the end state of the model
(to be written to by your function)
}
}

Your \code{update} function is the core here and should update the
state of the system - you are expected to update all values of
\code{state} on return.

It is very important that none of the functions in the class use
the R API in any way as these functions will be called in
parallel.

You must also provide a data-wrangling function for producing an
object of type \code{model::init_t} from an R list.  We use Rcpp for
this.  Your function will look like:\preformatted{template <>
model::init_t dust_data<model>(Rcpp::List data) \{
  return ...;
\}
}

With the body interacting with \code{data} to create an object of type
\code{model::init_t} and returning it.  This function will be called
in serial and may use anything in the Rcpp API.  All elements of
the returned object must be standard C/C++ (e.g., STL) types and
\emph{not} Rcpp types.
}

\examples{

# dust includes a couple of very simple examples
filename <- system.file("examples/walk.cpp", package = "dust")

# This model implements a random walk with a parameter coming from
# R representing the standard deviation of the walk
writeLines(readLines(filename))

# Compile and load the object:
model <- dust(filename)

# Print the object and you can see the methods that it provides
model

# Create a model with standard deviation of 1, initial step zero
# and 30 particles
obj <- model$new(list(sd = 1), 0, 30)
obj

# Curent state is all zero
obj$state()

# Current step is also zero
obj$step()

# Run the model up to step 100
obj$run(100)

# Reorder/resample the particles:
obj$reorder(sample(30, replace = TRUE))

# See the state again
obj$state()
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dust_interface$new()}}
\item \href{#method-run}{\code{dust_interface$run()}}
\item \href{#method-reset}{\code{dust_interface$reset()}}
\item \href{#method-state}{\code{dust_interface$state()}}
\item \href{#method-step}{\code{dust_interface$step()}}
\item \href{#method-reorder}{\code{dust_interface$reorder()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$new(
  data,
  step,
  n_particles,
  n_threads = 1L,
  n_generators = 1L,
  seed = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{Data to initialise your model with; a \code{list}
object, but the required elements will depend on the details of
your model.}

\item{\code{step}}{Initial step - must be nonnegative}

\item{\code{n_particles}}{Number of particles to create - must be at
least 1}

\item{\code{n_threads}}{Number of OMP threads to use, if \code{dust} and
your model were compiled with OMP support (details to come)}

\item{\code{n_generators}}{The number of random number generators to
use. Must be at least \code{n_threads} and a multiple of
\code{n_threads}.  You can use this to ensure reproducible results
when changing the number of threads, while preserving
statistically reasonable random numbers (for example setting
\code{n_generators = 64} and then using 1, 2, 4, 8, ..., 64 threads
as your computational capacity allows).}

\item{\code{seed}}{Seed to use for the random number generator
(positive integer)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
Run the model up to a point in time, returning the filtered state
at that point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$run(step_end)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{Step to run to (if less than or equal to the current
step(),silently nothing will happen)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Reset the model while preserving the random number stream state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$reset(data, step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{New data for the model (see constructor)}

\item{\code{step}}{New initial step for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Return full model state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$state()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-step"></a>}}
\if{latex}{\out{\hypertarget{method-step}{}}}
\subsection{Method \code{step()}}{
Return current model step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$step()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-reorder}{}}}
\subsection{Method \code{reorder()}}{
Reorder or resample particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_interface$reorder(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{An integer vector, with values between 1 and n_particles,
indicating the index of the current particles that new particles should
take.}
}
\if{html}{\out{</div>}}
}
}
}
