% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dust_class.R, R/interface.R
\name{dust}
\alias{dust}
\alias{dust_class}
\title{Create a dust model from a C++ input file}
\usage{
dust(filename, quiet = FALSE, workdir = NULL)
}
\arguments{
\item{filename}{The path to a single C++ file}

\item{quiet}{Logical, indicating if compilation messages from
\code{pkgbuild} should be displayed.  Error messages will be
displayed on compilation failure regardless of the value used.}

\item{workdir}{Optional working directory to use.  If \code{NULL}
uses a temporary directory.  By using a different directory of
your choosing you can see the generated code.}
}
\description{
Create a dust model from a C++ input file.  This function will
compile the dust support around your model and return an object
that can be used to work with the model (see the Details below).
}
\section{Input requirements}{


Your input dust model must satisfy a few requirements.
\itemize{
\item Define some class that implements your model (below \code{model} is
assumed to be the class name)
\item That class must define a type \code{internal_t} (so
\code{model::internal_t}) that contains its internal data that the
model may change during execution (i.e., that is not shared
between particles). If no such data is needed, you can do
\verb{typedef dust::no_internal internal_t} to indicate this.
\item We also need a type \code{shared_t} that contains \emph{constant} internal
data is shared between particles (e.g., dimensions, arrays that
are read but not written). If no such data is needed, you can do
\verb{typedef dust::no_shared shared_t} to indicate this.
\item That class must also include a typedef that describes the
model's floating point type, \code{real_t}. Most models can include
\verb{typedef double real_t;} in their public section.
\item The class must also include a typedef that describes the model's
\emph{data} type. This interface is subject to change, and for now
you should include \verb{typedef dust::no_data data_t} which marks
your class as not supporting data, which disables the
\code{compare_data} and \code{set_data} methods.
\item The class must have a constructor that accepts \verb{const dust::pars_t<model>& pars} for your type \code{model}. This will have
elements \code{shared} and \code{internal} which you can assign into your
model if needed.
\item The model must have a method \code{size()} returning \code{size_t} which
returns the size of the system. This size may depend on values
in your initialisation object but is constant within a model
run.
\item The model must have a method \code{initial} (which may not be
\code{const}), taking a step number (\code{size_t}) and returning a
\verb{std::vector<real_t>} of initial state for the model.
\item The model must have a method \code{update} taking arguments:
\itemize{
\item \verb{size_t step}: the step number
\item \verb{const double * state}: the state at the beginning of the
step
\item \verb{dust::rng_state_t<real_t>& rng_state}: the dust random number
generator state - this \emph{must} be a reference, as it will be modified
as random numbers are drawn
\item \code{double *state_next}: the end state of the model
(to be written to by your function)
}
}

Your \code{update} function is the core here and should update the
state of the system - you are expected to update all values of
\code{state} on return.

It is very important that none of the functions in the class use
the R API in any way as these functions will be called in
parallel.

You must also provide a data/parameter-wrangling function for
producing an object of type \verb{dust::pars_t<model>} from an R list.  We
use cpp11 for this.  Your function will look like:\preformatted{template <>
dust::pars_t<model> dust_pars<model>(cpp11::list pars) \{
  // ...
  return dust::pars_t<model>(shared, internal);
\}
}

With the body interacting with \code{pars} to create an object of type
\code{model::shared_t} and \code{model::internal_t} before returning the
\code{dust::pars_t} object.  This function will be called in serial
and may use anything in the cpp11 API.  All elements of the
returned object must be standard C/C++ (e.g., STL) types and
\emph{not} cpp11/R types. If your model uses only shared or internal,
you may use the single-argument constructor overload to
\code{dust::pars_t} which is equivalent to using \code{dust::no_shared} or
\code{dust::no_internal} for the missing argument.

Your model \emph{may} provided a template specialisation
\verb{dust_info<model>()} returning a \code{cpp11::sexp} for
returning arbitrary information back to the R session:\preformatted{template <>
cpp11::sexp dust_info<model>(const dust::pars_t<sir>& pars) \{
  return cpp11::wrap(...);
\}
}

What you do with this is up to you. If not present then the
\code{info()} method on the created object will return \code{NULL}.
Potential use cases for this are to return information about
variable ordering, or any processing done while accepting the
pars object used to create the pars fed into the particles.
}

\section{Configuring your model}{


You can optionally use C++ psuedo-attributes to configure the
generated code. Currently we support two attributes:
\itemize{
\item \verb{[[dust::class(classname)]]} will tell dust the name of your
target C++ class (in this example \code{classname}). You will need to
use this if your file uses more than a single class, as
otherwise will try to detect this using extremely simple
heuristics.
\item \verb{[[dust::name(modelname)]]} will tell dust the name to use for
the class in R code. For technical reasons this must be
alphanumeric characters only (sorry, no underscore) and must not
start with a number. If not included then the C++ type name will
be used (either specified with \verb{[[dust::class()]]} or detected).
}
}

\examples{

# dust includes a couple of very simple examples
filename <- system.file("examples/walk.cpp", package = "dust")

# This model implements a random walk with a parameter coming from
# R representing the standard deviation of the walk
writeLines(readLines(filename))

# The model can be compiled and loaded with dust::dust(filename)
# but it's faster in this example to use the prebuilt version in
# the package
model <- dust::dust_example("walk")

# Print the object and you can see the methods that it provides
model

# Create a model with standard deviation of 1, initial step zero
# and 30 particles
obj <- model$new(list(sd = 1), 0, 30)
obj

# Curent state is all zero
obj$state()

# Current step is also zero
obj$step()

# Run the model up to step 100
obj$run(100)

# Reorder/resample the particles:
obj$reorder(sample(30, replace = TRUE))

# See the state again
obj$state()
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dust_class$new()}}
\item \href{#method-name}{\code{dust_class$name()}}
\item \href{#method-param}{\code{dust_class$param()}}
\item \href{#method-run}{\code{dust_class$run()}}
\item \href{#method-set_index}{\code{dust_class$set_index()}}
\item \href{#method-index}{\code{dust_class$index()}}
\item \href{#method-n_threads}{\code{dust_class$n_threads()}}
\item \href{#method-n_state}{\code{dust_class$n_state()}}
\item \href{#method-n_particles}{\code{dust_class$n_particles()}}
\item \href{#method-set_state}{\code{dust_class$set_state()}}
\item \href{#method-reset}{\code{dust_class$reset()}}
\item \href{#method-set_pars}{\code{dust_class$set_pars()}}
\item \href{#method-state}{\code{dust_class$state()}}
\item \href{#method-step}{\code{dust_class$step()}}
\item \href{#method-reorder}{\code{dust_class$reorder()}}
\item \href{#method-resample}{\code{dust_class$resample()}}
\item \href{#method-info}{\code{dust_class$info()}}
\item \href{#method-pars}{\code{dust_class$pars()}}
\item \href{#method-rng_state}{\code{dust_class$rng_state()}}
\item \href{#method-set_rng_state}{\code{dust_class$set_rng_state()}}
\item \href{#method-has_openmp}{\code{dust_class$has_openmp()}}
\item \href{#method-n_pars}{\code{dust_class$n_pars()}}
\item \href{#method-set_n_threads}{\code{dust_class$set_n_threads()}}
\item \href{#method-has_compare}{\code{dust_class$has_compare()}}
\item \href{#method-set_data}{\code{dust_class$set_data()}}
\item \href{#method-compare_data}{\code{dust_class$compare_data()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new model. Note that the behaviour of this object
created by this function will change considerably based on
whether the \code{pars_multi} argument is \code{TRUE}. If not (the
default) then we create \code{n_particles} which all share the same
parameters as specified by the \code{pars} argument. If \code{pars_multi}
is \code{TRUE} then \code{pars} must be an unnamed list, and each element
of it represents a different set of parameters. We will
create \code{length(pars)} \emph{sets} of \code{n_particles} particles which
will be simulated together. These particles must have the same
dimension - that is, they must correspond to model state that
is the same size.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$new(
  pars,
  step,
  n_particles,
  n_threads = 1L,
  seed = NULL,
  pars_multi = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{Data to initialise your model with; a \code{list}
object, but the required elements will depend on the details of
your model. If \code{pars_multi} is \code{TRUE}, then this must be an
\emph{unnamed} list of \code{pars} objects (see Details).}

\item{\code{step}}{Initial step - must be nonnegative}

\item{\code{n_particles}}{Number of particles to create - must be at
least 1}

\item{\code{n_threads}}{Number of OMP threads to use, if \code{dust} and
your model were compiled with OMP support (details to come).
\code{n_particles} should be a multiple of \code{n_threads} (e.g., if you use 8
threads, then you should have 8, 16, 24, etc particles). However, this
is not compulsary.}

\item{\code{seed}}{The seed to use for the random number generator. Can
be a positive integer, \code{NULL} (initialise with R's random number
generator) or a \code{raw} vector of a length that is a multiple of
32 to directly initialise the generator (e..g., from the
\code{\link{dust}} object's \verb{$rng_state()} method).}

\item{\code{pars_multi}}{Logical, indicating if \code{pars} should be
interpreted as a set of different initialisations, and that we
should prepare \code{n_particles * length(pars)} particles for
simulation. This has an effect on many of the other methods of
the object.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-name"></a>}}
\if{latex}{\out{\hypertarget{method-name}{}}}
\subsection{Method \code{name()}}{
Returns friendly model name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$name()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-param"></a>}}
\if{latex}{\out{\hypertarget{method-param}{}}}
\subsection{Method \code{param()}}{
Returns parameter information, if provided by the model. This
describes the contents of pars passed to the constructor or to
\code{reset} as the \code{pars} argument, and the details depend on the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$param()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
Run the model up to a point in time, returning the filtered state
at that point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$run(step_end)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{Step to run to (if less than or equal to the current
step(), silently nothing will happen)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_index"></a>}}
\if{latex}{\out{\hypertarget{method-set_index}{}}}
\subsection{Method \code{set_index()}}{
Set the "index" vector that is used to return a subset of pars
after using \code{run()}. If this is not used then \code{run()} returns
all elements in your state vector, which may be excessive and slower
than necessary. This method must be called after any
call to \code{reset()} as \code{reset()} may change the size of the state
and that will invalidate the index.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_index(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{The index vector - must be an integer vector with
elements between 1 and the length of the state (this will be
validated, and an error thrown if an invalid index is given).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-index"></a>}}
\if{latex}{\out{\hypertarget{method-index}{}}}
\subsection{Method \code{index()}}{
Returns the \code{index} as set by \verb{$set_index}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$index()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_threads"></a>}}
\if{latex}{\out{\hypertarget{method-n_threads}{}}}
\subsection{Method \code{n_threads()}}{
Returns the number of threads that the model was constructed with
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_threads()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_state"></a>}}
\if{latex}{\out{\hypertarget{method-n_state}{}}}
\subsection{Method \code{n_state()}}{
Returns the length of the per-particle state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_state()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_particles"></a>}}
\if{latex}{\out{\hypertarget{method-n_particles}{}}}
\subsection{Method \code{n_particles()}}{
Returns the number of particles
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_particles()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_state}{}}}
\subsection{Method \code{set_state()}}{
Set the "state" vector for all particles, overriding whatever your
models \code{initial()} method provides.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_state(state, step = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{The state vector - can be either a numeric vector with the
same length as the model's current state (in which case the same
state is applied to all particles), or a numeric matrix with as
many rows as your model's state and as many columns as you have
particles (in which case you can set a number of different starting
states at once).}

\item{\code{step}}{If not \code{NULL}, then this sets the initial step. If this
is a vector (with the same length as the number of particles), then
particles are started from different initial steps and run up to the
larges step given (i.e., \code{max(step)})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Reset the model while preserving the random number stream state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reset(pars, step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{New pars for the model (see constructor)}

\item{\code{step}}{New initial step for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_pars"></a>}}
\if{latex}{\out{\hypertarget{method-set_pars}{}}}
\subsection{Method \code{set_pars()}}{
Set the 'pars' element in a dust object while holding model state,
index, etc constant. In contrast to \verb{$reset}, the old state must
be compatible with the new one (e.g., don't change model size), and
the index will remain valid.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_pars(pars)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{New pars for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Return full model state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$state(index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Optional index to select state using}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-step"></a>}}
\if{latex}{\out{\hypertarget{method-step}{}}}
\subsection{Method \code{step()}}{
Return current model step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$step()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-reorder}{}}}
\subsection{Method \code{reorder()}}{
Reorder particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reorder(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{An integer vector, with values between 1 and n_particles,
indicating the index of the current particles that new particles should
take.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-resample"></a>}}
\if{latex}{\out{\hypertarget{method-resample}{}}}
\subsection{Method \code{resample()}}{
Reasmple particles according to some weight.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$resample(weights)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{weights}}{A numeric vector representing particle weights.
For a "multi-parameter" dust object this should be be a matrix
with the number of rows being the number of particles per
parameter set and the number of columns being the number of
parameter sets.
long as all particles or be a matrix.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\if{latex}{\out{\hypertarget{method-info}{}}}
\subsection{Method \code{info()}}{
Returns information about the pars that your model was created with.
Only returns non-NULL if the model provides a \code{dust_info} template
specialisation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$info()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pars"></a>}}
\if{latex}{\out{\hypertarget{method-pars}{}}}
\subsection{Method \code{pars()}}{
Returns the \code{pars} object that your model was constructed with.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$pars()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rng_state"></a>}}
\if{latex}{\out{\hypertarget{method-rng_state}{}}}
\subsection{Method \code{rng_state()}}{
Returns the state of the random number generator. This returns a
raw vector of length 32 * n_particles. This can be useful for
debugging or for initialising other dust objects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$rng_state(first_only = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{first_only}}{Logical, indicating if we should return only the
\emph{first} particle's random number state. If \code{FALSE} (the default)
all particles states are returned, being 32 bytes per particle.
If \code{TRUE} then we take just the first particle's state, which
will be a total of 32 bytes. Both forms are suitable for seeding
a new \code{\link{dust}} object as the shorter version will be used for
the first particle, followed by jumps for each subsequent particle.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_rng_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_rng_state}{}}}
\subsection{Method \code{set_rng_state()}}{
Set the random number state for this model. This
replaces the RNG state that the model is using with a state of
your choosing, saved out from a different model object. This method
is designed to support advanced use cases where it is easier to
manipulate the state of the random number generator than the
internal state of the dust object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_rng_state(rng_state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{rng_state}}{A random number state, as saved out by the
\verb{$rng_state()} method. Note that unlike \code{seed} as passed to the
constructor, this \emph{must} be a raw vector of the expected length.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_openmp"></a>}}
\if{latex}{\out{\hypertarget{method-has_openmp}{}}}
\subsection{Method \code{has_openmp()}}{
Returns a logical, indicating if this model was compiled with
"OpenMP" support, in which case it will react to the \code{n_threads}
argument passed to the constructor. This method can also be used
as a static method by running it directly
as \code{dust_class$public_methods$has_openmp()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$has_openmp()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-n_pars"></a>}}
\if{latex}{\out{\hypertarget{method-n_pars}{}}}
\subsection{Method \code{n_pars()}}{
Returns the number of distinct pars elements required. This is \code{0}
where the object was initialised with \code{pars_multi = FALSE} and
an integer otherwise.  For multi-pars dust objects, Where \code{pars}
is accepted, you must provide an unnamed list of length \verb{$n_pars()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$n_pars()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_n_threads"></a>}}
\if{latex}{\out{\hypertarget{method-set_n_threads}{}}}
\subsection{Method \code{set_n_threads()}}{
Change the number of threads that the dust object will use. Your
model must be compiled with "OpenMP" support for this to have an
effect. Returns (invisibly) the previous value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_n_threads(n_threads)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_threads}}{The new number of threads to use. You may want to
wrap this argument in \code{\link[=dust_openmp_threads]{dust_openmp_threads()}} in order to
verify that you can actually use the number of threads
requested (based on environment variables and OpenMP support).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_compare"></a>}}
\if{latex}{\out{\hypertarget{method-has_compare}{}}}
\subsection{Method \code{has_compare()}}{
Returns a logical, indicating if this model was compiled with
"compare" support, in which case the \code{set_data} and \code{compare_data}
methods are available (otherwise these methods will error). This
method can also be used as a static method by running it directly
as \code{dust_class$public_methods$has_compare()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$has_compare()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_data"></a>}}
\if{latex}{\out{\hypertarget{method-set_data}{}}}
\subsection{Method \code{set_data()}}{
Set "data" into the model for use with the \verb{$compare_data()} method.
This is not supported by all models, depending on if they define a
\code{data_t} type.  See \code{\link[=dust_data]{dust_data()}} for a helper function to
construct suitable data and a description of the required format. You
will probably want to use that here, and definitely if using multiple
parameter sets.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_data(data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{A list of data to set.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compare_data"></a>}}
\if{latex}{\out{\hypertarget{method-compare_data}{}}}
\subsection{Method \code{compare_data()}}{
Compare the current model state against the data as set by
\code{set_data}. If there is no data set, or no data corresponding to
the current time then \code{NULL} is returned. Otherwise a numeric vector
the same length as the number of particles is returned. If model's
underlying \code{compare_data} function is stochastic, then each call to
this function may be result in a different answer.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$compare_data()}\if{html}{\out{</div>}}
}

}
}
