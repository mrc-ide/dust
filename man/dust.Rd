% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dust_class.R, R/interface.R
\name{dust}
\alias{dust}
\alias{dust_class}
\title{Create a dust model from a C++ input file}
\usage{
dust(
  filename,
  type = NULL,
  name = NULL,
  quiet = FALSE,
  workdir = NULL,
  gpu = FALSE
)
}
\arguments{
\item{filename}{The path to a single C++ file}

\item{type}{The name of the "type" (the C++ class) that represents
your model.  If \code{NULL} we try to work this out from your
file using extremely simple heuristics.}

\item{name}{The name of the model; for technical reasons this must
be alphanumeric characters only (sorry, no underscore) and must
not start with a number.  If \code{NULL} the value of
\code{type} will be used.}

\item{quiet}{Logical, indicating if compilation messages from
\code{pkgbuild} should be displayed.  Error messages will be
displayed on compilation failure regardless of the value used.}

\item{workdir}{Optional working directory to use.  If \code{NULL}
uses a temporary directory.  By using a different directory of
your choosing you can see the generated code.}

\item{gpu}{Create GPU code}
}
\description{
Create a dust model from a C++ input file.  This function will
compile the dust support around your model and return an object
that can be used to work with the model (see the Details below).
}
\section{Input requirements}{


Your input dust model must satisfy a few requirements.
\itemize{
\item Define some class that implements your model (below \code{model} is
assumed to be the class name)
\item That class must define a type \code{init_t} (so \code{model::init_t}) that
contains its internal data and the model must be constructable
with a const reference to this type (\verb{const model::init_t& data})
\item That class must also include typedefs that describe the standard
floating point and integer types (\code{real_t} and \code{int_t}
respectively). Most models can include \verb{typedef double real_t;}
and \verb{typedef int int_t;} in their public section.
\item The model must have a method \code{size()} returning \code{size_t} which
returns the size of the system. This size may depend on values
in your initialisation object but is constant within a model
run.
\item The model must have a method \code{initial} (which may not be
\code{const}), taking a step number (\code{size_t}) and returning a
\verb{std::vector<real_t>} of initial state for the model.
\item The model must have a method \code{update} taking arguments:
\itemize{
\item \verb{size_t step}: the step number
\item \verb{const double * state}: the state at the beginning of the
step
\item \verb{dust::rng_state_t<real_t>& rng_state}: the dust random number
generator state - this \emph{must} be a reference, as it will be modified
as random numbers are drawn
\item \code{double *state_next}: the end state of the model
(to be written to by your function)
}
}

Your \code{update} function is the core here and should update the
state of the system - you are expected to update all values of
\code{state} on return.

It is very important that none of the functions in the class use
the R API in any way as these functions will be called in
parallel.

You must also provide a data-wrangling function for producing an
object of type \code{model::init_t} from an R list.  We use cpp11 for
this.  Your function will look like:\preformatted{template <>
model::init_t dust_data<model>(cpp11::list data) \{
  return ...;
\}
}

With the body interacting with \code{data} to create an object of type
\code{model::init_t} and returning it.  This function will be called
in serial and may use anything in the cpp11 API.  All elements of
the returned object must be standard C/C++ (e.g., STL) types and
\emph{not} cpp11/R types.

Your model \emph{may} provided a template specialisation
\verb{dust_data<model::init_t>()} returning a \code{cpp11::sexp} for
returning arbitrary information back to the R session:\preformatted{template <>
cpp11::sexp dust_info<model>(const model::init_t& data) \{
  return cpp11::wrap(...);
\}
}

What you do with this is up to you. If not present then the
\code{info()} method on the created object will return \code{NULL}.
Potential use cases for this are to return information about
variable ordering, or any processing done while accepting the
data object used to create the data fed into the particles.
}

\examples{

# dust includes a couple of very simple examples
filename <- system.file("examples/walk.cpp", package = "dust")

# This model implements a random walk with a parameter coming from
# R representing the standard deviation of the walk
writeLines(readLines(filename))

# Compile and load the object:
model <- dust(filename, quiet = TRUE)

# Print the object and you can see the methods that it provides
model

# Create a model with standard deviation of 1, initial step zero
# and 30 particles
obj <- model$new(list(sd = 1), 0, 30)
obj

# Curent state is all zero
obj$state()

# Current step is also zero
obj$step()

# Run the model up to step 100
obj$run(100)

# Reorder/resample the particles:
obj$reorder(sample(30, replace = TRUE))

# See the state again
obj$state()
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dust_class$new()}}
\item \href{#method-name}{\code{dust_class$name()}}
\item \href{#method-run}{\code{dust_class$run()}}
\item \href{#method-set_index}{\code{dust_class$set_index()}}
\item \href{#method-set_state}{\code{dust_class$set_state()}}
\item \href{#method-reset}{\code{dust_class$reset()}}
\item \href{#method-state}{\code{dust_class$state()}}
\item \href{#method-step}{\code{dust_class$step()}}
\item \href{#method-reorder}{\code{dust_class$reorder()}}
\item \href{#method-info}{\code{dust_class$info()}}
\item \href{#method-rng_state}{\code{dust_class$rng_state()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$new(data, step, n_particles, n_threads = 1L, seed = 1L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{Data to initialise your model with; a \code{list}
object, but the required elements will depend on the details of
your model.}

\item{\code{step}}{Initial step - must be nonnegative}

\item{\code{n_particles}}{Number of particles to create - must be at
least 1}

\item{\code{n_threads}}{Number of OMP threads to use, if \code{dust} and
your model were compiled with OMP support (details to come).
\code{n_particles} should be a multiple of \code{n_threads} (e.g., if you use 8
threads, then you should have 8, 16, 24, etc particles). However, this
is not compulsary.}

\item{\code{seed}}{Seed to use for the random number generator
(positive integer)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-name"></a>}}
\if{latex}{\out{\hypertarget{method-name}{}}}
\subsection{Method \code{name()}}{
Returns friendly model name
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$name()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-run"></a>}}
\if{latex}{\out{\hypertarget{method-run}{}}}
\subsection{Method \code{run()}}{
Run the model up to a point in time, returning the filtered state
at that point.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$run(step_end)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step_end}}{Step to run to (if less than or equal to the current
step(), silently nothing will happen)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_index"></a>}}
\if{latex}{\out{\hypertarget{method-set_index}{}}}
\subsection{Method \code{set_index()}}{
Set the "index" vector that is used to return a subset of data
after using \code{run()}. If this is not used then \code{run()} returns
all elements in your state vector, which may be excessive and slower
than necessary. This method must be called after any
call to \code{reset()} as \code{reset()} may change the size of the state
and that will invalidate the index.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_index(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{The index vector - must be an integer vector with
elements between 1 and the length of the state (this will be
validated, and an error thrown if an invalid index is given).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_state"></a>}}
\if{latex}{\out{\hypertarget{method-set_state}{}}}
\subsection{Method \code{set_state()}}{
Set the "state" vector for all particles, overriding whatever your
models \code{initial()} method provides.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$set_state(state, step = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{The state vector - can be either a numeric vector with the
same length as the model's current state (in which case the same
state is applied to all particles), or a numeric matrix with as
many rows as your model's state and as many columns as you have
particles (in which case you can set a number of different starting
states at once).}

\item{\code{step}}{If not \code{NULL}, then this sets the initial step. If this
is a vector (with the same length as the number of particles), then
particles are started from different initial steps and run up to the
larges step given (i.e., \code{max(step)})}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Reset the model while preserving the random number stream state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reset(data, step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{New data for the model (see constructor)}

\item{\code{step}}{New initial step for the model (see constructor)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state"></a>}}
\if{latex}{\out{\hypertarget{method-state}{}}}
\subsection{Method \code{state()}}{
Return full model state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$state(index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{Optional index to select state using}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-step"></a>}}
\if{latex}{\out{\hypertarget{method-step}{}}}
\subsection{Method \code{step()}}{
Return current model step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$step()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reorder"></a>}}
\if{latex}{\out{\hypertarget{method-reorder}{}}}
\subsection{Method \code{reorder()}}{
Reorder or resample particles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$reorder(index)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index}}{An integer vector, with values between 1 and n_particles,
indicating the index of the current particles that new particles should
take.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\if{latex}{\out{\hypertarget{method-info}{}}}
\subsection{Method \code{info()}}{
Returns information about the data that your model was created with.
Only returns non-NULL if the model provides a \code{dust_info} template
specialisation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$info()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-rng_state"></a>}}
\if{latex}{\out{\hypertarget{method-rng_state}{}}}
\subsection{Method \code{rng_state()}}{
Returns the state of the random number generator. This returns a
raw vector of length 32 * n_particles. It is primarily intended for
debugging as one cannot (yet) initialise a dust object with this
state.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dust_class$rng_state()}\if{html}{\out{</div>}}
}

}
}
