##' Updates a dust model in a package. The user-provided code is
##' assumed to the in `inst/dust` as a series of C++ files; a file
##' `inst/dust/model.cpp` will be transformed into a file
##' `src/model.cpp`.
##'
##' If your code provides a class `model` then dust will create C++
##' functions such as `dust_model_alloc` - if your code also includes
##' names such as this, compilation will fail due to duplicate
##' symbols.
##'
##' We add "Rcpp attributes" to the created functions, and will run
##' \code{\link{compileAttributes}} on them once the generated code
##' has been created.
##'
##' @param path Path to the package
##'
##' @param compile Should the package be compiled?
##'
##' @title Create dust model in package
##' @return Nothing, this function is called for its side effects
##' @export
##' @author Rich Fitzjohn
dust_package <- function(path, compile = TRUE) {
  ## 1. check that the package is legit
  root <- package_validate(path)
  path_dust <- file.path(root, "inst/dust")
  path_src <- file.path(root, "src")
  path_r <- file.path(root, "R")

  ## 2. find target model files

  ## TODO: support alternative location, perhaps not in package - that
  ## will suit odin.
  files <- dir(path_dust, pattern = "\\.cpp$")
  if (length(files) == 0L) {
    stop(sprintf("No dust files found in '%s/inst/dust'", root))
  }

  ## 3. identify destination src files, validate signature
  package_validate_destination(root, files)

  ## 4. generate code
  template_r <- read_lines(dust_file("template/dust.R"))
  template_cpp <- read_lines(dust_file("template/dust.cpp"))
  data <- lapply(file.path(path_dust, files), package_generate,
                 template_cpp, template_r)

  dir.create(path_src, FALSE, TRUE)
  dir.create(path_r, FALSE, TRUE)
  for (d in data) {
    writeLines(d$cpp, file.path(path_src, d$filename))
  }

  code_r <- c("## Generated by dust - do not edit",
              vcapply(data, "[[", "r"))
  writeLines(code_r, file.path(path_r, "dust.R"))

  ## 5. compile attributes
  Rcpp::compileAttributes(path)

  ## 6. return path
  path
}


package_validate <- function(path) {
  paths <- c("DESCRIPTION", "NAMESPACE", "inst/dust")
  for (p in paths) {
    if (!file.exists(file.path(path, p))) {
      stop(sprintf("Expected a file '%s' at path '%s'", p, path))
    }
  }

  desc <- pkgload::pkg_desc(path)
  deps <- desc$get_deps()
  package_validate_has_dep(deps, "Rcpp", "Imports")
  package_validate_has_dep(deps, "Rcpp", "LinkingTo")
  package_validate_has_dep(deps, "dust", "LinkingTo")

  ## TODO: check namespace file - parse it directly and look for the
  ## useDynLib expression.

  path
}


## NOTE: Should be able to do this directly with desc but there is a
## small bug: https://github.com/r-lib/desc/pull/97
package_validate_has_dep <- function(deps, package, type) {
  if (!any(deps$package == package & deps$type == type)) {
    stop(sprintf("Expected package '%s' as '%s' in DESCRIPTION",
                 package, type))
  }
}


package_validate_destination <- function(path, files) {
  check <- c(file.path(path, "src", files),
             file.path(path, "R", "dust.R"))
  for (f in check[file.exists(check)]) {
    if (!isTRUE(grepl("^(//|##) Generated by dust", readLines(f, 1)))) {
      stop(sprintf(
        "File '%s' does not look like it was created by dust - stopping",
        f))
    }
  }
}


package_generate <- function(filename, template_cpp, template_r) {
  type <- dust_guess_type(readLines(filename))
  name <- type
  model <- read_lines(filename)
  data <- list(model = model, name = name, type = type)
  list(
    filename = basename(filename),
    cpp = glue_whisker(template_cpp, data),
    r = glue_whisker(template_r, data))
}
