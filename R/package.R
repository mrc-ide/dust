##' Updates a dust model in a package. The user-provided code is
##' assumed to the in `inst/dust` as a series of C++ files; a file
##' `inst/dust/model.cpp` will be transformed into a file
##' `src/model.cpp`.
##'
##' If your code provides a class `model` then dust will create C++
##' functions such as `dust_model_alloc` - if your code also includes
##' names such as this, compilation will fail due to duplicate
##' symbols.
##'
##' We add "Rcpp attributes" to the created functions, and will run
##' \code{\link{compileAttributes}} on them once the generated code
##' has been created.
##'
##' @param path Path to the package
##'
##' @title Create dust model in package
##' @return Nothing, this function is called for its side effects
##' @export
dust_package <- function(path) {
  ## 1. check that the package is legit
  root <- package_validate(path)
  path_dust <- file.path(root, "inst/dust")
  path_src <- file.path(root, "src")
  path_r <- file.path(root, "R")

  ## 2. find target model files

  ## TODO: support alternative location, perhaps not in package - that
  ## will suit odin.
  files <- dir(path_dust, pattern = "\\.cpp$")
  if (length(files) == 0L) {
    stop(sprintf("No dust files found in '%s/inst/dust'", root))
  }

  ## 3. identify destination src files, validate signature
  package_validate_destination(root, files)

  ## 4. generate code
  template_r <- readLines(dust_file("template/dust.R.template"))
  ## Drop all the roxygen comments here before writing out the R
  ## code. The reasoning here is that we have no way of tying this to
  ## the correct help page, and the user may not be using roxygen at
  ## all, and they could just link to the help file ?dust to get the
  ## same documentation.
  template_r <- paste(template_r[!grepl("\\s*#+'", template_r)],
                      collapse = "\n")
  template_cpp <- read_lines(dust_file("template/dust.cpp"))
  data <- lapply(file.path(path_dust, files), package_generate,
                 template_cpp, template_r)

  dir.create(path_src, FALSE, TRUE)
  dir.create(path_r, FALSE, TRUE)
  for (d in data) {
    code_cpp <- c(dust_header("//"), d$cpp)
    writeLines(code_cpp, file.path(path_src, d$filename))
  }

  code_r <- c(dust_header("##"), vcapply(data, "[[", "r"))
  writeLines(code_r, file.path(path_r, "dust.R"))

  ## 5. compile attributes
  Rcpp::compileAttributes(path)

  ## 6. return path, invisibly
  invisible(path)
}


package_validate <- function(path) {
  paths <- c("DESCRIPTION", "NAMESPACE")
  for (p in paths) {
    if (!file.exists(file.path(path, p))) {
      stop(sprintf("Expected a file '%s' at path '%s'", p, path))
    }
  }

  desc <- pkgload::pkg_desc(path)
  deps <- desc$get_deps()
  package_validate_has_dep(deps, "Rcpp", "Imports")
  package_validate_has_dep(deps, "Rcpp", "LinkingTo")
  package_validate_has_dep(deps, "dust", "LinkingTo")

  name <- desc$get_field("Package")
  package_validate_namespace(file.path(path, "NAMESPACE"), name)

  path
}


## NOTE: Should be able to do this directly with desc but there is a
## small bug: https://github.com/r-lib/desc/pull/97
package_validate_has_dep <- function(deps, package, type) {
  if (!any(deps$package == package & deps$type == type)) {
    stop(sprintf("Expected package '%s' as '%s' in DESCRIPTION",
                 package, type))
  }
}


package_validate_destination <- function(path, files) {
  check <- c(file.path(path, "src", files),
             file.path(path, "R", "dust.R"))
  for (f in check[file.exists(check)]) {
    if (!isTRUE(grepl("^(//|##) Generated by dust", readLines(f, 1)))) {
      stop(sprintf(
        "File '%s' does not look like it was created by dust - stopping",
        f))
    }
  }
}


package_validate_namespace <- function(path, name) {
  exprs <- as.list(parse(path))
  package_validate_namespace_usedynlib(exprs, name)
  package_validate_namespace_import(exprs)
}


package_validate_namespace_usedynlib <- function(exprs, name) {
  for (e in exprs) {
    if (is_call(e, "useDynLib")) {
      lib <- e[[2]]
      if (is.name(lib)) {
        lib <- deparse(lib)
      }
      if (identical(lib, name)) {
        return()
      }
      stop(sprintf("Found a useDynLib call but not for '%s'", name))
    }
  }
  stop("Did not find a useDynLib call in NAMESPACE")
}


package_validate_namespace_import <- function(exprs) {
  for (e in exprs) {
    if (is_call(e, "import") || is_call(e, "importFrom")) {
      lib <- e[[2]]
      if (is.name(lib)) {
        lib <- deparse(lib)
      }
      if (identical(lib, "Rcpp")) {
        return()
      }
    }
  }
  stop("Did not find an import or importFrom call to Rcpp in NAMESPACE")
}


package_generate <- function(filename, template_cpp, template_r) {
  type <- dust_guess_type(readLines(filename))
  name <- type
  model <- read_lines(filename)
  data <- list(model = model, name = name, type = type)
  list(
    filename = basename(filename),
    cpp = glue_whisker(template_cpp, data),
    r = glue_whisker(template_r, data))
}
