##' Updates a dust model in a package. The user-provided code is
##' assumed to the in `inst/dust` as a series of C++ files; a file
##' `inst/dust/model.cpp` will be transformed into a file
##' `src/model.cpp`.
##'
##' If your code provides a class `model` then dust will create C++
##' functions such as `dust_model_alloc` - if your code also includes
##' names such as this, compilation will fail due to duplicate
##' symbols.
##'
##' We add "cpp11 attributes" to the created functions, and will run
##' \code{\link{cpp_register}} on them once the generated code
##' has been created.
##'
##' @param path Path to the package
##'
##' @param quiet Passed to `cpp11::cpp_register`, if `TRUE` suppresses
##'   informational notices about updates to the cpp11 files
##'
##' @param gpu Create GPU code (currently must be shared across all models)
##'
##' @title Create dust model in package
##' @return Nothing, this function is called for its side effects
##' @export
dust_package <- function(path, quiet = FALSE, gpu = FALSE) {
  ## 1. check that the package is legit
  root <- package_validate(path)
  path_dust <- file.path(root, "inst/dust")
  path_src <- file.path(root, "src")
  path_r <- file.path(root, "R")

  ## 2. find target model files

  ## TODO: support alternative location, perhaps not in package - that
  ## will suit odin.
  files <- dir(path_dust, pattern = "\\.cpp$")
  if (length(files) == 0L) {
    stop(sprintf("No dust files found in '%s/inst/dust'", root))
  }

  ## 3. identify destination src files, validate signature
  package_validate_destination(root, files)

  ## 4. generate code
  template_r <- readLines(dust_file("template/dust.R.template"))
  ## Drop all the roxygen comments here before writing out the R
  ## code. The reasoning here is that we have no way of tying this to
  ## the correct help page, and the user may not be using roxygen at
  ## all, and they could just link to the help file ?dust to get the
  ## same documentation.
  template_r <- paste(template_r[!grepl("\\s*#+'", template_r)],
                      collapse = "\n")

  data <- lapply(file.path(path_dust, files), package_generate, gpu)

  dir.create(path_src, FALSE, TRUE)
  dir.create(path_r, FALSE, TRUE)

  for (d in data) {
    for (p in names(d$src)) {
      writeLines(c(dust_header("//"), d$src[[p]]), file.path(path_src, p))
    }
  }

  code_r <- c(dust_header("##"), vcapply(data, "[[", "r"))
  writeLines(code_r, file.path(path_r, "dust.R"))

  if (gpu) {
    template <- read_lines(dust_file("template/gpu/Makevars.pkg"))
    objects <- paste(sort(c(sub("\\.cpp", ".o", files), "cpp11.o")),
                     collapse = " ")
    writeLines(glue_whisker(template, list(objects = objects)),
               file.path(path, "src/Makevars"))
  }

  ## 5. compile attributes
  cpp11::cpp_register(path, quiet = quiet)

  ## 6. return path, invisibly
  invisible(path)
}


package_validate <- function(path) {
  paths <- c("DESCRIPTION", "NAMESPACE")
  for (p in paths) {
    if (!file.exists(file.path(path, p))) {
      stop(sprintf("Expected a file '%s' at path '%s'", p, path))
    }
  }

  desc <- pkgload::pkg_desc(path)
  deps <- desc$get_deps()
  package_validate_has_dep(deps, "cpp11", "LinkingTo")
  package_validate_has_dep(deps, "dust", "LinkingTo")

  name <- desc$get_field("Package")
  package_validate_namespace(file.path(path, "NAMESPACE"), name)

  path
}


## NOTE: Should be able to do this directly with desc but there is a
## small bug: https://github.com/r-lib/desc/pull/97
package_validate_has_dep <- function(deps, package, type) {
  if (!any(deps$package == package & deps$type == type)) {
    stop(sprintf("Expected package '%s' as '%s' in DESCRIPTION",
                 package, type))
  }
}


package_validate_destination <- function(path, files) {
  check <- c(file.path(path, "src", files),
             file.path(path, "R", "dust.R"))
  for (f in check[file.exists(check)]) {
    if (!isTRUE(grepl("^(//|##) Generated by dust", readLines(f, 1)))) {
      stop(sprintf(
        "File '%s' does not look like it was created by dust - stopping",
        f))
    }
  }
}


package_validate_namespace <- function(path, name) {
  exprs <- as.list(parse(path))
  package_validate_namespace_usedynlib(exprs, name)
}


package_validate_namespace_usedynlib <- function(exprs, name) {
  for (e in exprs) {
    if (is_call(e, "useDynLib")) {
      lib <- e[[2]]
      if (is.name(lib)) {
        lib <- deparse(lib)
      }
      if (identical(lib, name)) {
        return()
      }
      stop(sprintf("Found a useDynLib call but not for '%s'", name))
    }
  }
  stop("Did not find a useDynLib call in NAMESPACE")
}


package_generate <- function(filename, gpu) {
  type <- dust_guess_type(readLines(filename))
  name <- type
  model <- read_lines(filename)
  data <- list(model = model, name = name, type = type)

  template_r <- read_lines(dust_file("template/gpu/dust.cu"))
  code_r <- glue_whisker(template_r, data)

  if (gpu) {
    template_cu <- read_lines(dust_file("template/gpu/dust.cu"))
    template_hpp <- read_lines(dust_file("template/gpu/dust.hpp"))
    code_cu <- glue_whisker(template_cu, data)
    code_hpp <- glue_whisker(template_hpp, data)
    filename_cu <- sub("\\.cpp", ".cu", basename(filename))
    filename_hpp <- sub("\\.cpp", ".hpp", basename(filename))
    src <- set_names(c(code_cu, code_hpp), c(filename_cu, filename_hpp))
    list(src = src, r = code_r)
  } else {
    template_cpp <- read_lines(dust_file("template/dust.cpp"))
    code_cpp <- glue_whisker(template_cpp, data)
    src <- set_names(code_cpp, basename(filename))
    list(src = src, r = code_r)
  }
}
